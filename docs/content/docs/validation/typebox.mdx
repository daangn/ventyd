---
title: TypeBox
description: Complete guide to using TypeBox with Ventyd
---

# TypeBox

TypeBox is a JSON Schema validation library with native Standard Schema support. It's the fastest validation option and excellent for API development and OpenAPI integration.

## Why TypeBox?

- **Ultra-Fast Performance**: 10x faster than Zod in many scenarios
- **JSON Schema Compatible**: Generate OpenAPI/Swagger specifications
- **Standard Schema Native**: First-class support for Standard Schema
- **Runtime Type Checking**: Comprehensive validation at runtime
- **Static Type Inference**: Excellent TypeScript support
- **API-First Design**: Perfect for REST and GraphQL APIs

## Installation


  
    ```bash
    pnpm add ventyd @sinclair/typebox @sinclair/typemap
    ```
  
  
    ```bash
    yarn add ventyd @sinclair/typebox @sinclair/typemap
    ```
  
  
    ```bash
    npm install ventyd @sinclair/typebox @sinclair/typemap
    ```
  


## Basic Usage

### 1. Define Your Schema

Start by defining your entity's events and state using TypeBox:

```typescript
import { defineSchema } from 'ventyd';
import { typebox, Type } from 'ventyd/typebox';

const userSchema = defineSchema("user", {
  schema: typebox({
    event: {
      created: Type.Object({
        email: Type.String({ format: 'email' }),
        name: Type.String({ minLength: 1, maxLength: 100 }),
        age: Type.Integer({ minimum: 0, maximum: 150 })
      }),
      profile_updated: Type.Object({
        name: Type.Optional(Type.String({ minLength: 1, maxLength: 100 })),
        age: Type.Optional(Type.Integer({ minimum: 0, maximum: 150 }))
      }),
      deleted: Type.Object({
        reason: Type.Optional(Type.String())
      })
    },
    state: Type.Object({
      email: Type.String(),
      name: Type.String(),
      age: Type.Integer(),
      deletedAt: Type.Union([Type.String(), Type.Null()])
    })
  }),
  initialEventName: "user:created"
});
```

### 2. Create a Reducer

Define how events transform your entity state:

```typescript
import { defineReducer } from 'ventyd';

const userReducer = defineReducer(userSchema, (prevState, event) => {
  switch (event.eventName) {
    case "user:created":
      return {
        email: event.body.email,
        name: event.body.name,
        age: event.body.age,
        deletedAt: null
      };

    case "user:profile_updated":
      return {
        ...prevState,
        ...(event.body.name && { name: event.body.name }),
        ...(event.body.age !== undefined && { age: event.body.age })
      };

    case "user:deleted":
      return {
        ...prevState,
        deletedAt: event.eventCreatedAt
      };

    default:
      return prevState;
  }
});
```

### 3. Create Your Entity

Extend the `Entity` class with business logic:

```typescript
import { Entity, mutation } from 'ventyd';

class User extends Entity(userSchema, userReducer) {
  get isDeleted() {
    return this.state.deletedAt !== null;
  }

  updateProfile = mutation(this, (dispatch, updates: { name?: string; age?: number }) => {
    if (this.isDeleted) {
      throw new Error("Cannot update deleted user");
    }
    dispatch("user:profile_updated", updates);
  });

  delete = mutation(this, (dispatch, reason?: string) => {
    if (this.isDeleted) {
      throw new Error("User is already deleted");
    }
    dispatch("user:deleted", { reason });
  });
}
```

### 4. Use Your Entity

Create instances, dispatch events, and persist:

```typescript
// Create a new user
const user = User.create({
  body: {
    email: "alice@example.com",
    name: "Alice Smith",
    age: 25
  }
});

// Update the user's profile
user.updateProfile({ age: 26 });

// Delete the user
user.delete("Account deletion request");

// Access the current state
console.log(user.state.name); // "Alice Smith"
console.log(user.isDeleted); // true

// Persist events
await userRepository.commit(user);
```

## TypeBox Features in Ventyd

TypeBox's powerful type system works seamlessly with Ventyd. Here are some advanced patterns:

### JSON Schema Properties

Take advantage of JSON Schema features:

```typescript
const productSchema = defineSchema("product", {
  schema: typebox({
    event: {
      created: Type.Object({
        name: Type.String({
          minLength: 1,
          maxLength: 200,
          description: "Product name"
        }),
        sku: Type.String({
          pattern: "^[A-Z0-9]{8}$",
          description: "Stock keeping unit"
        }),
        price: Type.Number({
          minimum: 0,
          maximum: 999999,
          description: "Product price in USD"
        }),
        description: Type.Optional(Type.String({
          maxLength: 5000
        }))
      })
    },
    state: Type.Object({
      name: Type.String(),
      sku: Type.String(),
      price: Type.Number(),
      description: Type.Optional(Type.String())
    })
  }),
  initialEventName: "product:created"
});
```

### Complex Objects and Arrays

Handle nested structures with ease:

```typescript
const orderSchema = defineSchema("order", {
  schema: typebox({
    event: {
      created: Type.Object({
        customerId: Type.String({ format: 'uuid' }),
        items: Type.Array(
          Type.Object({
            productId: Type.String({ format: 'uuid' }),
            quantity: Type.Integer({ minimum: 1 }),
            price: Type.Number({ minimum: 0 })
          }),
          { minItems: 1, maxItems: 1000 }
        ),
        shippingAddress: Type.Object({
          street: Type.String(),
          city: Type.String(),
          zipCode: Type.String({ pattern: "^[0-9]{5}$" }),
          country: Type.String({ minLength: 2, maxLength: 2 })
        }),
        total: Type.Number({ minimum: 0 }),
        currency: Type.Enum({ USD: 'USD', EUR: 'EUR', GBP: 'GBP' })
      })
    },
    state: Type.Object({
      customerId: Type.String(),
      items: Type.Array(Type.Object({
        productId: Type.String(),
        quantity: Type.Integer(),
        price: Type.Number()
      })),
      shippingAddress: Type.Object({
        street: Type.String(),
        city: Type.String(),
        zipCode: Type.String(),
        country: Type.String()
      }),
      total: Type.Number(),
      currency: Type.String()
    })
  }),
  initialEventName: "order:created"
});
```

### Union and Intersection Types

Combine types for complex schemas:

```typescript
const paymentSchema = defineSchema("payment", {
  schema: typebox({
    event: {
      credit_card_charged: Type.Object({
        amount: Type.Number({ minimum: 0 }),
        cardToken: Type.String(),
        last4Digits: Type.String({ pattern: "^[0-9]{4}$" })
      }),
      bank_transfer_initiated: Type.Object({
        amount: Type.Number({ minimum: 0 }),
        accountNumber: Type.String(),
        routingNumber: Type.String()
      })
    },
    state: Type.Object({
      method: Type.Enum({ CREDIT_CARD: 'CREDIT_CARD', BANK: 'BANK' }),
      amount: Type.Number(),
      status: Type.String()
    })
  }),
  initialEventName: "payment:credit_card_charged"
});
```

### Optional Fields

Use `Type.Optional()` for optional properties:

```typescript
const profileSchema = defineSchema("profile", {
  schema: typebox({
    event: {
      created: Type.Object({
        bio: Type.Optional(Type.String({ maxLength: 500 })),
        website: Type.Optional(Type.String({ format: 'uri' })),
        avatar: Type.Optional(Type.String({ format: 'uri' })),
        socialLinks: Type.Optional(Type.Object({
          twitter: Type.Optional(Type.String()),
          github: Type.Optional(Type.String()),
          linkedin: Type.Optional(Type.String())
        }))
      })
    },
    state: Type.Object({
      bio: Type.Optional(Type.String()),
      website: Type.Optional(Type.String()),
      avatar: Type.Optional(Type.String()),
      socialLinks: Type.Optional(Type.Object({
        twitter: Type.Optional(Type.String()),
        github: Type.Optional(Type.String()),
        linkedin: Type.Optional(Type.String())
      }))
    })
  }),
  initialEventName: "profile:created"
});
```

### Format Validators

Use standard JSON Schema formats for validation:

```typescript
const contactSchema = defineSchema("contact", {
  schema: typebox({
    event: {
      created: Type.Object({
        email: Type.String({ format: 'email' }),
        phone: Type.String({ pattern: "^\\+?[1-9]\\d{1,14}$" }),
        website: Type.Optional(Type.String({ format: 'uri' })),
        avatar: Type.Optional(Type.String({ format: 'uri' })),
        dateOfBirth: Type.String({ format: 'date-time' })
      })
    },
    state: Type.Object({
      email: Type.String(),
      phone: Type.String(),
      website: Type.Optional(Type.String()),
      avatar: Type.Optional(Type.String()),
      dateOfBirth: Type.String()
    })
  }),
  initialEventName: "contact:created"
});
```

## Custom Namespace Separator

By default, events use a colon separator (e.g., `user:created`). Customize it:

```typescript
const userSchema = defineSchema("user", {
  schema: typebox({
    event: {
      created: Type.Object({ email: Type.String() }),
      profile_updated: Type.Object({ name: Type.String() })
    },
    state: Type.Object({ email: Type.String(), name: Type.String() }),
    namespaceSeparator: "/" // Events: "user/created", "user/profile_updated"
  }),
  initialEventName: "user/created" // Must match separator
});
```

Other separator examples:
- `"."` → `user.created`
- `"-"` → `user-created`
- `"_"` → `user_created`

## Advanced Patterns

### Type-Safe Event Dispatching

Leverage TypeScript for type-safe events:

```typescript
class Product extends Entity(productSchema, productReducer) {
  updatePrice = mutation(this, (dispatch, price: number) => {
    if (price < 0) {
      throw new Error("Price cannot be negative");
    }
    dispatch("product:price_updated", { price }); // ✅ Type-checked
  });

  updateInventory = mutation(this, (dispatch, quantity: number) => {
    dispatch("product:inventory_updated", { quantity }); // ✅ Type-checked
  });
}
```

### Composable Schema Templates

Create reusable schema components:

```typescript
const addressType = Type.Object({
  street: Type.String(),
  city: Type.String(),
  zipCode: Type.String(),
  country: Type.String()
});

const contactType = Type.Object({
  email: Type.String({ format: 'email' }),
  phone: Type.String(),
  address: addressType
});

const customerSchema = defineSchema("customer", {
  schema: typebox({
    event: {
      created: Type.Object({
        name: Type.String(),
        contact: contactType
      })
    },
    state: Type.Object({
      name: Type.String(),
      contact: contactType
    })
  }),
  initialEventName: "customer:created"
});
```

### OpenAPI Integration

Generate OpenAPI specifications from your schemas:

```typescript
import { Type } from '@sinclair/typebox';

// Your TypeBox schema automatically generates valid JSON Schema
const apiSchema = Type.Object({
  id: Type.String({ description: "Unique identifier" }),
  name: Type.String({ description: "Customer name", minLength: 1 }),
  email: Type.String({ description: "Customer email", format: 'email' }),
  status: Type.Enum({ ACTIVE: 'ACTIVE', INACTIVE: 'INACTIVE' })
});

// Can be used directly in OpenAPI/Swagger definitions
export const openAPIComponent = {
  schema: apiSchema
};
```

## Performance Tips

### Validation Performance

TypeBox is optimized for speed:

```typescript
// TypeBox compilation creates optimized validators
import { Value } from '@sinclair/typebox/value';

const userType = Type.Object({
  email: Type.String(),
  age: Type.Integer()
});

// Pre-compile for better performance
const validate = Value.Errors(userType);
const errors = [...validate({ email: 'invalid', age: 'not-a-number' })];
```

### Schema Reuse

Define schemas once and reuse them:

```typescript
const userBaseType = Type.Object({
  id: Type.String(),
  email: Type.String(),
  createdAt: Type.String()
});

// Extend base schemas
const userWithProfileType = Type.Intersect([
  userBaseType,
  Type.Object({
    bio: Type.Optional(Type.String()),
    avatar: Type.Optional(Type.String())
  })
]);
```

## Comparison with Other Libraries

| Aspect | TypeBox | Valibot | Zod | ArkType |
|--------|---------|---------|-----|---------|
| **Bundle Size** | ⭐⭐⭐⭐ 2KB | ⭐⭐⭐⭐⭐ 1KB | ⭐⭐⭐ 4KB | ⭐⭐⭐⭐ 2KB |
| **Performance** | ⭐⭐⭐⭐⭐ Fastest | ⭐⭐⭐⭐ Fast | ⭐⭐⭐ Good | ⭐⭐⭐⭐⭐ Fastest |
| **JSON Schema** | ⭐⭐⭐⭐⭐ Native | Limited | Limited | No |
| **TypeScript** | ⭐⭐⭐⭐ Great | ⭐⭐⭐⭐⭐ Excellent | ⭐⭐⭐⭐ Great | ⭐⭐⭐⭐⭐ Excellent |
| **Ecosystem** | ⭐⭐⭐ Good | ⭐⭐⭐ Growing | ⭐⭐⭐⭐⭐ Large | ⭐⭐⭐ Growing |

## Pros and Cons

### Pros

- **Ultra-Fast Performance**: 10x faster validation than Zod
- **JSON Schema Compatible**: Generate OpenAPI/Swagger specs
- **Smallest Among Enterprise Options**: 2KB gzipped
- **Native TypeScript Support**: Excellent type inference
- **API-First Design**: Perfect for REST/GraphQL APIs
- **Static Type Generation**: Can generate TypeScript types
- **No Runtime Dependencies**: Pure JavaScript

### Cons

- **Learning Curve**: More complex API than Zod or Valibot
- **Smaller Ecosystem**: Fewer third-party integrations than Zod
- **Documentation**: Less extensive than Zod
- **Community Size**: Smaller community than Zod

## Use Cases

### Perfect For:

- High-performance APIs and services
- OpenAPI/Swagger documentation
- Performance-critical applications
- JSON Schema-based workflows
- Real-time applications with high validation throughput

### Less Ideal For:

- Simple schemas (Valibot might be better)
- Projects needing large ecosystem (Zod)
- Rapid prototyping with maximum guidance

## Next Steps

- **Explore [Valibot](/docs/validation/valibot)** for simpler API
- **Try [Zod](/docs/validation/zod)** for larger ecosystem
- **Check [ArkType](/docs/validation/arktype)** for elegant syntax
- **Build your first API** with TypeBox
- **Learn [Best Practices](/docs/best-practices)** for event sourcing

<Callout type="tip">
**Pro Tip: TypeBox + OpenAPI**

TypeBox is the best choice if you need to generate OpenAPI/Swagger documentation. Your TypeBox schemas are already valid JSON Schema!
</Callout>

---

<Cards>
  <Card
    title="Validation Overview"
    description="Learn about all validation libraries"
    href="/docs/validation"
  />
  <Card
    title="Valibot Guide"
    description="Lightweight and modular"
    href="/docs/validation/valibot"
  />
  <Card
    title="Zod Guide"
    description="Popular and well-established"
    href="/docs/validation/zod"
  />
  <Card
    title="ArkType Guide"
    description="Ultra-fast validation"
    href="/docs/validation/arktype"
  />
</Cards>
