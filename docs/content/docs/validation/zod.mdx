---
title: Zod
description: Complete guide to using Zod with Ventyd
---

# Zod

Zod is a popular, TypeScript-first schema validation library with a large, mature ecosystem. It's an excellent choice if you want maximum community support and integrations.

## Why Zod?

- **Large Ecosystem**: Many integrations and community projects
- **Well-Established**: Mature project with extensive documentation
- **TypeScript First**: Excellent type inference
- **Chainable API**: Fluent, readable schema definitions
- **Great Documentation**: Comprehensive guides and examples
- **Community Support**: Large community for help and questions
- **Framework Integrations**: Works with Next.js, tRPC, Prisma, and more

## Installation


  
    ```bash
    pnpm add ventyd zod
    ```
  
  
    ```bash
    yarn add ventyd zod
    ```
  
  
    ```bash
    npm install ventyd zod
    ```
  


## Basic Usage

### 1. Define Your Schema

Start by defining your entity's events and state using Zod schemas:

```typescript
import { defineSchema } from 'ventyd';
import { zod, z } from 'ventyd/zod';

const userSchema = defineSchema("user", {
  schema: zod({
    event: {
      created: z.object({
        email: z.string().email(),
        name: z.string().min(1).max(100),
        age: z.number().int().min(0).max(150)
      }),
      profile_updated: z.object({
        name: z.string().min(1).max(100).optional(),
        age: z.number().int().min(0).max(150).optional()
      }),
      deleted: z.object({
        reason: z.string().optional()
      })
    },
    state: z.object({
      email: z.string().email(),
      name: z.string(),
      age: z.number(),
      deletedAt: z.string().nullable().optional()
    })
  }),
  initialEventName: "user:created"
});
```

### 2. Create a Reducer

Define how events transform your entity state:

```typescript
import { defineReducer } from 'ventyd';

const userReducer = defineReducer(userSchema, (prevState, event) => {
  switch (event.eventName) {
    case "user:created":
      return {
        email: event.body.email,
        name: event.body.name,
        age: event.body.age,
        deletedAt: null
      };

    case "user:profile_updated":
      return {
        ...prevState,
        ...(event.body.name && { name: event.body.name }),
        ...(event.body.age !== undefined && { age: event.body.age })
      };

    case "user:deleted":
      return {
        ...prevState,
        deletedAt: event.eventCreatedAt
      };

    default:
      return prevState;
  }
});
```

### 3. Create Your Entity

Extend the `Entity` class with business logic:

```typescript
import { Entity, mutation } from 'ventyd';

class User extends Entity(userSchema, userReducer) {
  get isDeleted() {
    return this.state.deletedAt !== null;
  }

  updateProfile = mutation(this, (dispatch, updates: { name?: string; age?: number }) => {
    if (this.isDeleted) {
      throw new Error("Cannot update deleted user");
    }
    dispatch("user:profile_updated", updates);
  });

  delete = mutation(this, (dispatch, reason?: string) => {
    if (this.isDeleted) {
      throw new Error("User is already deleted");
    }
    dispatch("user:deleted", { reason });
  });
}
```

### 4. Use Your Entity

Create instances, dispatch events, and persist:

```typescript
// Create a new user
const user = User.create({
  body: {
    email: "jane@example.com",
    name: "Jane Doe",
    age: 28
  }
});

// Update the user's profile
user.updateProfile({ age: 29 });

// Delete the user
user.delete("Account closure");

// Access the current state
console.log(user.state.name); // "Jane Doe"
console.log(user.isDeleted); // true

// Persist events
await userRepository.commit(user);
```

## Zod Features in Ventyd

Zod's powerful validators work seamlessly with Ventyd. Here are some advanced patterns:

### Chainable Methods

Build complex validations with fluent chains:

```typescript
const customerSchema = defineSchema("customer", {
  schema: zod({
    event: {
      created: z.object({
        email: z.string().email().max(255),
        phone: z.string().regex(/^\d{10}$/),
        age: z.number().int().min(18).max(120),
        status: z.enum(["active", "inactive", "pending"])
      })
    },
    state: z.object({
      email: z.string(),
      phone: z.string(),
      age: z.number(),
      status: z.string()
    })
  }),
  initialEventName: "customer:created"
});
```

### Array and Nested Objects

Handle complex nested structures:

```typescript
const orderSchema = defineSchema("order", {
  schema: zod({
    event: {
      created: z.object({
        customerId: z.string().uuid(),
        items: z.array(
          z.object({
            productId: z.string().uuid(),
            quantity: z.number().int().positive(),
            price: z.number().nonnegative()
          })
        ).min(1),
        shippingAddress: z.object({
          street: z.string(),
          city: z.string(),
          zipCode: z.string(),
          country: z.string()
        }),
        total: z.number().positive(),
        currency: z.enum(["USD", "EUR", "GBP"])
      })
    },
    state: z.object({
      customerId: z.string(),
      items: z.array(z.object({
        productId: z.string(),
        quantity: z.number(),
        price: z.number()
      })),
      shippingAddress: z.object({
        street: z.string(),
        city: z.string(),
        zipCode: z.string(),
        country: z.string()
      }),
      total: z.number(),
      currency: z.string()
    })
  }),
  initialEventName: "order:created"
});
```

### Optional and Nullable

Handle optional and nullable values:

```typescript
const profileSchema = defineSchema("profile", {
  schema: zod({
    event: {
      created: z.object({
        bio: z.string().optional(),
        website: z.string().url().optional(),
        avatar: z.string().url().nullable(),
        socialLinks: z.object({
          twitter: z.string().optional(),
          github: z.string().optional(),
          linkedin: z.string().optional()
        }).optional()
      })
    },
    state: z.object({
      bio: z.string().optional(),
      website: z.string().optional(),
      avatar: z.string().nullable(),
      socialLinks: z.object({
        twitter: z.string().optional(),
        github: z.string().optional(),
        linkedin: z.string().optional()
      }).optional()
    })
  }),
  initialEventName: "profile:created"
});
```

### Custom Validation with `refine()`

Add custom validation logic:

```typescript
const userSchema = defineSchema("user", {
  schema: zod({
    event: {
      created: z.object({
        email: z.string().email(),
        password: z.string().min(8),
        confirmPassword: z.string()
      }).refine(
        (data) => data.password === data.confirmPassword,
        {
          message: "Passwords do not match",
          path: ["confirmPassword"]
        }
      )
    },
    state: z.object({
      email: z.string(),
      password: z.string()
    })
  }),
  initialEventName: "user:created"
});
```

### Union Types

Handle multiple event variants:

```typescript
const notificationSchema = defineSchema("notification", {
  schema: zod({
    event: {
      email_sent: z.object({
        to: z.string().email(),
        subject: z.string(),
        body: z.string()
      }),
      sms_sent: z.object({
        phoneNumber: z.string(),
        message: z.string()
      }),
      push_sent: z.object({
        deviceToken: z.string(),
        title: z.string(),
        body: z.string()
      })
    },
    state: z.object({
      lastNotificationType: z.enum(["email", "sms", "push"]),
      lastSentAt: z.string()
    })
  }),
  initialEventName: "notification:email_sent"
});
```

## Custom Namespace Separator

By default, events use a colon separator (e.g., `user:created`). Customize it:

```typescript
const userSchema = defineSchema("user", {
  schema: zod({
    event: {
      created: z.object({ email: z.string().email() }),
      profile_updated: z.object({ name: z.string() })
    },
    state: z.object({ email: z.string(), name: z.string() }),
    namespaceSeparator: "/" // Events: "user/created", "user/profile_updated"
  }),
  initialEventName: "user/created" // Must match separator
});
```

Other separator examples:
- `"."` → `user.created`
- `"-"` → `user-created`
- `"_"` → `user_created`

## Advanced Patterns

### Type-Safe Event Dispatching

Leverage TypeScript for type-safe events:

```typescript
class Product extends Entity(productSchema, productReducer) {
  updatePrice = mutation(this, (dispatch, price: number) => {
    if (price < 0) {
      throw new Error("Price cannot be negative");
    }
    dispatch("product:price_updated", { price }); // ✅ Type-checked
  });

  updateInventory = mutation(this, (dispatch, quantity: number) => {
    dispatch("product:inventory_updated", { quantity }); // ✅ Type-checked
  });
}
```

### Discriminated Unions

Use discriminated unions for event variants:

```typescript
const paymentSchema = defineSchema("payment", {
  schema: zod({
    event: {
      initiated: z.object({
        amount: z.number().positive(),
        method: z.enum(["credit_card", "bank_transfer", "paypal"])
      }),
      completed: z.object({
        transactionId: z.string(),
        confirmationCode: z.string()
      }),
      failed: z.object({
        reason: z.enum(["insufficient_funds", "invalid_card", "network_error"]),
        errorMessage: z.string()
      })
    },
    state: z.object({
      status: z.enum(["initiated", "completed", "failed"]),
      amount: z.number(),
      method: z.string(),
      transactionId: z.string().optional()
    })
  }),
  initialEventName: "payment:initiated"
});
```

### Composition with Schema Reuse

Reuse schemas across multiple entities:

```typescript
const addressSchema = z.object({
  street: z.string(),
  city: z.string(),
  zipCode: z.string(),
  country: z.string()
});

const userSchema = defineSchema("user", {
  schema: zod({
    event: {
      created: z.object({
        email: z.string().email(),
        address: addressSchema
      })
    },
    state: z.object({
      email: z.string(),
      address: addressSchema
    })
  }),
  initialEventName: "user:created"
});

const companySchema = defineSchema("company", {
  schema: zod({
    event: {
      created: z.object({
        name: z.string(),
        address: addressSchema
      })
    },
    state: z.object({
      name: z.string(),
      address: addressSchema
    })
  }),
  initialEventName: "company:created"
});
```

## Error Handling

Zod provides detailed error information:

```typescript
import { z } from 'zod';

const schema = z.object({
  email: z.string().email(),
  age: z.number().min(18)
});

try {
  const result = schema.parse({
    email: "invalid-email",
    age: 16
  });
} catch (error) {
  if (error instanceof z.ZodError) {
    console.error(error.errors);
    // [
    //   { code: 'invalid_string', path: ['email'], message: 'Invalid email' },
    //   { code: 'too_small', path: ['age'], message: 'Must be >= 18' }
    // ]
  }
}
```

## Framework Integration

### Next.js with Zod

Use Zod schemas for API validation:

```typescript
import { zod } from 'ventyd/zod';
import { z } from 'zod';

const userSchema = defineSchema("user", {
  schema: zod({
    event: {
      created: z.object({
        email: z.string().email(),
        name: z.string()
      })
    },
    state: z.object({
      email: z.string(),
      name: z.string()
    })
  }),
  initialEventName: "user:created"
});

// Use with API routes
export async function POST(req: Request) {
  const body = await req.json();
  const user = User.create({ body });
  await userRepository.commit(user);
  return Response.json(user.state);
}
```

## Comparison with Other Libraries

| Aspect | Zod | Valibot | TypeBox | ArkType |
|--------|-----|---------|---------|---------|
| **Bundle Size** | ⭐⭐⭐ 4KB | ⭐⭐⭐⭐⭐ 1KB | ⭐⭐⭐⭐ 2KB | ⭐⭐⭐⭐ 2KB |
| **Performance** | ⭐⭐⭐ Good | ⭐⭐⭐⭐ Fast | ⭐⭐⭐⭐⭐ Fastest | ⭐⭐⭐⭐⭐ Fastest |
| **TypeScript** | ⭐⭐⭐⭐ Great | ⭐⭐⭐⭐⭐ Excellent | ⭐⭐⭐⭐ Great | ⭐⭐⭐⭐⭐ Excellent |
| **Ecosystem** | ⭐⭐⭐⭐⭐ Large | ⭐⭐⭐ Growing | ⭐⭐⭐ Good | ⭐⭐⭐ Growing |
| **Learning Curve** | ⭐⭐⭐⭐ Moderate | ⭐⭐⭐⭐⭐ Easy | ⭐⭐⭐⭐ Moderate | ⭐⭐⭐⭐⭐ Easy |

## Pros and Cons

### Pros

- **Large Ecosystem**: Many third-party integrations and libraries
- **Well-Documented**: Extensive official documentation and guides
- **Community Support**: Large, active community
- **Framework Integrations**: Works with Next.js, tRPC, Prisma, etc.
- **Established**: Mature project with proven track record
- **Chainable API**: Fluent, readable schema definitions
- **Good Error Messages**: Detailed validation error reporting

### Cons

- **Bundle Size**: Larger than Valibot (~4KB vs 1KB)
- **Performance**: Slower than TypeBox and ArkType
- **Maturity Ceiling**: Fewer groundbreaking features
- **Over-Featured**: May include features you don't need

## Next Steps

- **Try [Valibot](/docs/validation/valibot)** for smaller bundle size
- **Explore [TypeBox](/docs/validation/typebox)** for JSON Schema
- **Check [ArkType](/docs/validation/arktype)** for ultra-fast validation
- **Build your first entity** with Zod
- **Learn [Best Practices](/docs/best-practices)** for event sourcing

<Callout type="tip">
**Pro Tip: Zod + Next.js**

Zod is an excellent choice if you're building with Next.js or other modern frameworks. The ecosystem integration makes API validation seamless.
</Callout>

---

<Cards>
  <Card
    title="Validation Overview"
    description="Learn about all validation libraries"
    href="/docs/validation"
  />
  <Card
    title="Valibot Guide"
    description="Lightweight and modular"
    href="/docs/validation/valibot"
  />
  <Card
    title="TypeBox Guide"
    description="JSON Schema compatible"
    href="/docs/validation/typebox"
  />
  <Card
    title="ArkType Guide"
    description="Ultra-fast validation"
    href="/docs/validation/arktype"
  />
</Cards>
