---
title: ArkType
description: Complete guide to using ArkType with Ventyd
---

# ArkType

ArkType is a powerful validation library with ultra-fast performance and an elegant, concise syntax. It's perfect for projects that prioritize speed and readability.

## Why ArkType?

- **Ultra-Fast Performance**: Competitive with TypeBox, 10x faster than Zod
- **Elegant Syntax**: Minimal, readable type definitions
- **Excellent Error Messages**: Clear, actionable validation feedback
- **Type-Safe**: Full TypeScript integration with excellent inference
- **Zero Dependencies**: Lightweight and focused
- **Modern API**: Built for modern TypeScript applications

## Installation


  
    ```bash
    pnpm add ventyd arktype
    ```
  
  
    ```bash
    yarn add ventyd arktype
    ```
  
  
    ```bash
    npm install ventyd arktype
    ```
  


## Basic Usage

### 1. Define Your Schema

Start by defining your entity's events and state using ArkType's elegant syntax:

```typescript
import { defineSchema } from 'ventyd';
import { arktype, type } from 'ventyd/arktype';

const userSchema = defineSchema("user", {
  schema: arktype({
    event: {
      created: type({
        email: "string.email",
        name: "string>1&<=100",
        age: "number>=0&<=150"
      }),
      profile_updated: type({
        "name?": "string>1&<=100",
        "age?": "number>=0&<=150"
      }),
      deleted: type({
        "reason?": "string"
      })
    },
    state: type({
      email: "string",
      name: "string",
      age: "number",
      "deletedAt?": "string | null"
    })
  }),
  initialEventName: "user:created"
});
```

### 2. Create a Reducer

Define how events transform your entity state:

```typescript
import { defineReducer } from 'ventyd';

const userReducer = defineReducer(userSchema, (prevState, event) => {
  switch (event.eventName) {
    case "user:created":
      return {
        email: event.body.email,
        name: event.body.name,
        age: event.body.age,
        deletedAt: null
      };

    case "user:profile_updated":
      return {
        ...prevState,
        ...(event.body.name && { name: event.body.name }),
        ...(event.body.age !== undefined && { age: event.body.age })
      };

    case "user:deleted":
      return {
        ...prevState,
        deletedAt: event.eventCreatedAt
      };

    default:
      return prevState;
  }
});
```

### 3. Create Your Entity

Extend the `Entity` class with business logic:

```typescript
import { Entity, mutation } from 'ventyd';

class User extends Entity(userSchema, userReducer) {
  get isDeleted() {
    return this.state.deletedAt !== null;
  }

  updateProfile = mutation(this, (dispatch, updates: { name?: string; age?: number }) => {
    if (this.isDeleted) {
      throw new Error("Cannot update deleted user");
    }
    dispatch("user:profile_updated", updates);
  });

  delete = mutation(this, (dispatch, reason?: string) => {
    if (this.isDeleted) {
      throw new Error("User is already deleted");
    }
    dispatch("user:deleted", { reason });
  });
}
```

### 4. Use Your Entity

Create instances, dispatch events, and persist:

```typescript
// Create a new user
const user = User.create({
  body: {
    email: "bob@example.com",
    name: "Bob Johnson",
    age: 35
  }
});

// Update the user's profile
user.updateProfile({ age: 36 });

// Delete the user
user.delete("Account closed");

// Access the current state
console.log(user.state.name); // "Bob Johnson"
console.log(user.isDeleted); // true

// Persist events
await userRepository.commit(user);
```

## ArkType Syntax Guide

ArkType uses a concise, intuitive syntax for type definitions:

### Basic Types

```typescript
type({
  // String variants
  name: "string",           // Required string
  "nickname?": "string",    // Optional string
  tag: "string>0",          // String length > 0
  code: "string<10",        // String length < 10
  middle: "string>=2<=20",  // String 2-20 characters

  // Number variants
  count: "number",          // Required number
  "score?": "number",       // Optional number
  min: "number>=0",         // Number >= 0
  max: "number<=100",       // Number <= 100
  range: "number>=10<=99",  // Number 10-99

  // Boolean and literals
  active: "boolean",
  role: "'user'|'admin'",   // Literal union

  // Arrays
  tags: "string[]",         // Array of strings
  items: "number[]>0",      // Non-empty array of numbers

  // Dates
  created: "Date",
  updated: "Date>2024"      // Date after 2024
})
```

### Advanced Patterns

```typescript
const advancedSchema = type({
  // Email validation
  email: "string.email",

  // URL validation
  website: "string.url",

  // IP address
  ip: "string.ip",

  // UUID
  id: "string.uuid",

  // Multiple constraints
  username: "string.alphanumeric&>3&<20",

  // Conditional types
  profile: {
    "bio?": "string<=500",
    "avatar?": "string.url"
  },

  // Nested arrays
  items: {
    "productId?": "string",
    "quantity?": "number>=1"
  }[]
});
```

## ArkType Features in Ventyd

ArkType's powerful type system works seamlessly with Ventyd. Here are some advanced patterns:

### Complex Objects

Define nested structures:

```typescript
const orderSchema = defineSchema("order", {
  schema: arktype({
    event: {
      created: type({
        customerId: "string",
        items: [{
          productId: "string",
          quantity: "number>=1",
          price: "number>=0"
        }],
        shippingAddress: {
          street: "string",
          city: "string",
          zipCode: "string",
          country: "string"
        },
        total: "number>=0",
        currency: "'USD'|'EUR'|'GBP'"
      })
    },
    state: type({
      customerId: "string",
      items: [{
        productId: "string",
        quantity: "number",
        price: "number"
      }],
      shippingAddress: {
        street: "string",
        city: "string",
        zipCode: "string",
        country: "string"
      },
      total: "number",
      currency: "string"
    })
  }),
  initialEventName: "order:created"
});
```

### Union Types

Handle multiple variants elegantly:

```typescript
const paymentSchema = defineSchema("payment", {
  schema: arktype({
    event: {
      credit_card_charged: type({
        amount: "number>=0",
        cardToken: "string",
        last4: "string.numeric&=4"
      }),
      bank_transfer_initiated: type({
        amount: "number>=0",
        accountNumber: "string",
        routingNumber: "string"
      }),
      failed: type({
        reason: "'insufficient_funds'|'invalid_card'|'network_error'",
        message: "string"
      })
    },
    state: type({
      method: "'CREDIT_CARD'|'BANK'|'PAYPAL'",
      amount: "number",
      status: "'initiated'|'completed'|'failed'"
    })
  }),
  initialEventName: "payment:credit_card_charged"
});
```

### Email and URL Validation

Built-in validators for common patterns:

```typescript
const contactSchema = defineSchema("contact", {
  schema: arktype({
    event: {
      created: type({
        email: "string.email",
        phone: "string",
        website: "string.url",
        "bio?": "string<=500",
        "twitter?": "string.url"
      })
    },
    state: type({
      email: "string",
      phone: "string",
      website: "string",
      "bio?": "string",
      "twitter?": "string"
    })
  }),
  initialEventName: "contact:created"
});
```

### Optional and Nullable

Express optional and nullable fields clearly:

```typescript
const profileSchema = defineSchema("profile", {
  schema: arktype({
    event: {
      created: type({
        "bio?": "string",           // Optional
        "avatar?": "string.url",    // Optional URL
        "banner?": "string.url",    // Optional URL
        settings: {
          "notifications?": "boolean",
          "newsletter?": "boolean"
        }
      })
    },
    state: type({
      "bio?": "string",
      "avatar?": "string",
      "banner?": "string",
      settings: {
        "notifications?": "boolean",
        "newsletter?": "boolean"
      }
    })
  }),
  initialEventName: "profile:created"
});
```

## Custom Namespace Separator

By default, events use a colon separator (e.g., `user:created`). Customize it:

```typescript
const userSchema = defineSchema("user", {
  schema: arktype({
    event: {
      created: type({ email: "string.email" }),
      profile_updated: type({ name: "string" })
    },
    state: type({ email: "string", name: "string" }),
    namespaceSeparator: "/" // Events: "user/created", "user/profile_updated"
  }),
  initialEventName: "user/created" // Must match separator
});
```

Other separator examples:
- `"."` → `user.created`
- `"-"` → `user-created`
- `"_"` → `user_created`

## Advanced Patterns

### Type-Safe Event Dispatching

Leverage TypeScript for type-safe events:

```typescript
class Product extends Entity(productSchema, productReducer) {
  updatePrice = mutation(this, (dispatch, price: number) => {
    if (price < 0) {
      throw new Error("Price cannot be negative");
    }
    dispatch("product:price_updated", { price }); // ✅ Type-checked
  });

  updateInventory = mutation(this, (dispatch, quantity: number) => {
    if (quantity < 0) {
      throw new Error("Quantity cannot be negative");
    }
    dispatch("product:inventory_updated", { quantity }); // ✅ Type-checked
  });
}
```

### Composable Validators

Reuse type definitions across schemas:

```typescript
const addressType = {
  street: "string",
  city: "string",
  zipCode: "string",
  country: "string"
};

const contactType = {
  email: "string.email",
  phone: "string",
  address: addressType
};

const customerSchema = defineSchema("customer", {
  schema: arktype({
    event: {
      created: type({
        name: "string",
        contact: contactType
      })
    },
    state: type({
      name: "string",
      contact: contactType
    })
  }),
  initialEventName: "customer:created"
});

const vendorSchema = defineSchema("vendor", {
  schema: arktype({
    event: {
      created: type({
        name: "string",
        contact: contactType,
        taxId: "string"
      })
    },
    state: type({
      name: "string",
      contact: contactType,
      taxId: "string"
    })
  }),
  initialEventName: "vendor:created"
});
```

### Conditional Validation

Implement business logic validation:

```typescript
class Order extends Entity(orderSchema, orderReducer) {
  confirmOrder = mutation(this, (dispatch) => {
    // Business rule validation
    if (this.state.total <= 0) {
      throw new Error("Order total must be positive");
    }
    if (this.state.items.length === 0) {
      throw new Error("Order must have at least one item");
    }

    // Dispatch validated event
    dispatch("order:confirmed", {});
  });
}
```

## Performance Characteristics

ArkType is built for speed:

```typescript
// Validation is extremely fast
// Comparable to TypeBox, 10x faster than Zod
import { validate } from 'arktype';

const schema = type({
  email: "string.email",
  age: "number>=18"
});

// Validation is optimized and cached
const result = validate({ email: "user@example.com", age: 25 });
```

## Comparison with Other Libraries

| Aspect | ArkType | Valibot | Zod | TypeBox |
|--------|---------|---------|-----|---------|
| **Bundle Size** | ⭐⭐⭐⭐ 2KB | ⭐⭐⭐⭐⭐ 1KB | ⭐⭐⭐ 4KB | ⭐⭐⭐⭐ 2KB |
| **Performance** | ⭐⭐⭐⭐⭐ Fastest | ⭐⭐⭐⭐ Fast | ⭐⭐⭐ Good | ⭐⭐⭐⭐⭐ Fastest |
| **Syntax** | ⭐⭐⭐⭐⭐ Elegant | ⭐⭐⭐⭐⭐ Clean | ⭐⭐⭐⭐ Chainable | ⭐⭐⭐⭐ Verbose |
| **TypeScript** | ⭐⭐⭐⭐⭐ Excellent | ⭐⭐⭐⭐⭐ Excellent | ⭐⭐⭐⭐ Great | ⭐⭐⭐⭐ Great |
| **Ecosystem** | ⭐⭐⭐ Growing | ⭐⭐⭐ Growing | ⭐⭐⭐⭐⭐ Large | ⭐⭐⭐ Good |

## Pros and Cons

### Pros

- **Ultra-Fast Performance**: Competitive with TypeBox
- **Elegant Syntax**: Minimal, readable type definitions
- **Small Bundle Size**: ~2KB gzipped
- **Excellent Error Messages**: Clear, actionable feedback
- **Type-Safe**: Full TypeScript integration
- **Zero Dependencies**: Lightweight and focused
- **Modern API**: Built for modern development

### Cons

- **Smaller Ecosystem**: Fewer third-party integrations than Zod
- **Smaller Community**: Less community support than Zod
- **Newer Project**: Less battle-tested than Zod
- **Learning Curve**: Unique syntax takes some time to learn
- **Documentation**: Still growing documentation

## Use Cases

### Perfect For:

- High-performance applications
- Projects prioritizing readable code
- Real-time applications with high validation throughput
- Elegant, minimal syntax preferences
- Performance-critical services

### Good For:

- Most modern applications
- TypeScript projects
- Teams valuing code readability

### Less Ideal For:

- Projects needing large ecosystem (Zod)
- Teams unfamiliar with ArkType's syntax
- Rapid prototyping with maximum guidance

## Next Steps

- **Try [Valibot](/docs/validation/valibot)** for simplicity
- **Explore [Zod](/docs/validation/zod)** for ecosystem
- **Check [TypeBox](/docs/validation/typebox)** for JSON Schema
- **Build your first entity** with ArkType
- **Learn [Best Practices](/docs/best-practices)** for event sourcing

<Callout type="tip">
**Pro Tip: ArkType for Performance**

ArkType is the best choice if you need ultra-fast validation or prefer elegant, concise syntax. It's modern, focused, and getting better every day.
</Callout>

---

<Cards>
  <Card
    title="Validation Overview"
    description="Learn about all validation libraries"
    href="/docs/validation"
  />
  <Card
    title="Valibot Guide"
    description="Lightweight and modular"
    href="/docs/validation/valibot"
  />
  <Card
    title="Zod Guide"
    description="Popular and well-established"
    href="/docs/validation/zod"
  />
  <Card
    title="TypeBox Guide"
    description="JSON Schema compatible"
    href="/docs/validation/typebox"
  />
</Cards>
