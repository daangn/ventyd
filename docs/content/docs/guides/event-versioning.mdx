---
title: Event Versioning Strategy
description: Handle event schema evolution and migrations
---

# Event Versioning Strategy

Event schemas evolve over time. This guide covers strategies for managing event versioning, schema migrations, and backward compatibility.

## The Versioning Challenge

Once an event is in your event store, you can't change its structure. You need strategies to handle evolution without breaking existing events.

```typescript
// Version 1: Simple event
const event_v1 = {
  eventName: 'order:created',
  body: {
    items: ['product-1', 'product-2']
  }
};

// Version 2: More detailed items
const event_v2 = {
  eventName: 'order:created',
  body: {
    items: [
      { productId: 'product-1', quantity: 1, price: 100 },
      { productId: 'product-2', quantity: 2, price: 50 }
    ]
  }
};

// How do we handle both?
```

## Strategy 1: Event Name Versioning

Create separate events for different schema versions.

### Implementation

```typescript
const orderSchema = defineSchema("order", {
  schema: valibot({
    event: {
      // Version 1 - simple items list
      created: v.object({
        items: v.array(v.string()),
        total: v.number()
      }),

      // Version 2 - detailed items
      created_v2: v.object({
        items: v.array(v.object({
          productId: v.string(),
          quantity: v.number(),
          price: v.number()
        })),
        total: v.number()
      }),

      // Version 3 - with metadata
      created_v3: v.object({
        items: v.array(v.object({
          productId: v.string(),
          quantity: v.number(),
          price: v.number()
        })),
        total: v.number(),
        source: v.string(),
        metadata: v.optional(v.object({}))
      })
    },
    state: v.object({
      items: v.array(v.object({
        productId: v.string(),
        quantity: v.number(),
        price: v.number()
      })),
      total: v.number(),
      source: v.optional(v.string()),
      metadata: v.optional(v.object({}))
    })
  }),
  initialEventName: "order:created_v3"
});

// Reducer handles all versions
const orderReducer = defineReducer(orderSchema, (prevState, event) => {
  switch (event.eventName) {
    case "order:created":
      // Handle v1: convert items from strings to objects
      return {
        items: event.body.items.map((productId: string) => ({
          productId,
          quantity: 1,
          price: 0 // Unknown
        })),
        total: event.body.total,
        source: undefined,
        metadata: undefined
      };

    case "order:created_v2":
      // Handle v2: items already detailed, but missing source
      return {
        items: event.body.items,
        total: event.body.total,
        source: undefined,
        metadata: undefined
      };

    case "order:created_v3":
      // Handle v3: full format
      return {
        items: event.body.items,
        total: event.body.total,
        source: event.body.source,
        metadata: event.body.metadata
      };

    default:
      return prevState;
  }
});
```

### Using the Versioned Schema

```typescript
class Order extends Entity(orderSchema, orderReducer) {
  // New code uses latest version
  static create(data: OrderCreationData) {
    return super.create({
      body: {
        items: data.items,
        total: data.total,
        source: 'api',
        metadata: data.metadata
      }
    });
  }
}

// Events dispatched use latest version
const order = Order.create({
  items: [
    { productId: 'p1', quantity: 1, price: 100 }
  ],
  total: 100
});
// Dispatches: order:created_v3
```

**Advantages:**
- Clear versioning
- Easy to see which version was used
- Simple logic in reducer
- Good for analytics (can track v1 vs v2 usage)

**Disadvantages:**
- Event names become cluttered
- Reducer code grows with versions
- Need to maintain multiple code paths

## Strategy 2: Upcasting

Transform events to newer versions during loading.

### Implementation

```typescript
// Define upcasting functions
function upcastOrderCreated(event: any): any {
  if (event.eventName !== 'order:created') {
    return event;
  }

  // Detect version by event structure
  const isV1 = event.body.items?.some(
    (item: any) => typeof item === 'string'
  );

  if (isV1) {
    // Upcast v1 to v2
    return {
      ...event,
      eventName: 'order:created_v2',
      body: {
        items: event.body.items.map((productId: string) => ({
          productId,
          quantity: 1,
          price: 0
        })),
        total: event.body.total
      }
    };
  }

  // Check if v2 -> v3
  const isV2 = !event.body.source && !event.body.metadata;

  if (isV2) {
    return {
      ...event,
      eventName: 'order:created_v3',
      body: {
        ...event.body,
        source: 'legacy',
        metadata: undefined
      }
    };
  }

  // Already v3
  return event;
}

// Create custom adapter that upcasts
const createUpcastingAdapter = (baseAdapter: Adapter): Adapter => {
  return {
    async getEventsByEntityId(params) {
      const events = await baseAdapter.getEventsByEntityId(params);

      // Upcast events to current version
      return events.map(upcastOrderCreated);
    },

    async commitEvents(params) {
      return baseAdapter.commitEvents(params);
    }
  };
};

// Use upcasting adapter
const orderRepository = createRepository(Order, {
  adapter: createUpcastingAdapter(mongoAdapter)
});
```

### Upcasting with Metadata

```typescript
// Version with metadata in event
interface VersionedEvent {
  eventName: string;
  body: any;
  version?: number;
  eventCreatedAt: string;
}

function upcastWithVersion(event: VersionedEvent): VersionedEvent {
  const version = event.version || detectVersion(event);

  switch (version) {
    case 1:
      // Upcast v1 -> v2
      const v2 = {
        ...event,
        version: 2,
        body: migrateV1toV2(event.body)
      };
      // Fallthrough to check v2 -> v3
      return upcastWithVersion(v2);

    case 2:
      // Upcast v2 -> v3
      return {
        ...event,
        version: 3,
        body: migrateV2toV3(event.body)
      };

    case 3:
    default:
      return event;
  }
}

function detectVersion(event: VersionedEvent): number {
  if (event.version) return event.version;

  // Infer version from structure
  if (event.body.items?.some((i: any) => typeof i === 'string')) {
    return 1; // Old format: items as strings
  }
  if (!event.body.source) {
    return 2; // Missing source field
  }
  return 3; // Current version
}

function migrateV1toV2(body: any) {
  return {
    items: body.items.map((productId: string) => ({
      productId,
      quantity: 1,
      price: 0
    })),
    total: body.total
  };
}

function migrateV2toV3(body: any) {
  return {
    ...body,
    source: 'legacy-v2',
    metadata: undefined
  };
}
```

**Advantages:**
- Clean event names (no versioning in event names)
- Reducer stays simple (only handles current version)
- Transparent to reducer code
- Can migrate events in background

**Disadvantages:**
- Upcasting logic can be complex
- Hard to debug which version was original
- Need to maintain conversion functions

## Strategy 3: Hybrid Approach

Combine versioning and upcasting for flexibility.

```typescript
// Use event name versioning for major changes
const orderSchema = defineSchema("order", {
  schema: valibot({
    event: {
      // Major versions as separate events
      created: v.object(/* v1 format */),
      created_v2: v.object(/* v2 format */),

      // Minor versions handled via upcasting
      status_changed: v.object({
        newStatus: v.string()
      }),
      status_changed_with_reason: v.object({
        newStatus: v.string(),
        reason: v.string() // New in v2
      })
    },
    state: v.object({
      status: v.string(),
      statusReason: v.optional(v.string())
    })
  }),
  initialEventName: "order:created_v2"
});

const upcastingAdapter = createUpcastingAdapter({
  // Handle minor version differences
  upcast: (event: any) => {
    if (event.eventName === 'order:status_changed') {
      // Upcast to include reason
      return {
        ...event,
        eventName: 'order:status_changed_with_reason',
        body: {
          ...event.body,
          reason: 'migrated' // Default reason
        }
      };
    }
    return event;
  }
});

const orderRepository = createRepository(Order, {
  adapter: upcastingAdapter
});
```

## Real-World Migration Scenarios

### Scenario 1: Adding Optional Field

```typescript
// Old format
const oldEvent = {
  eventName: 'user:created',
  body: { email: 'john@example.com' }
};

// New format with optional field
const newEvent = {
  eventName: 'user:created',
  body: {
    email: 'john@example.com',
    timezone: 'UTC' // New optional field
  }
};

// Simple upcasting
function upcastUserCreated(event: any) {
  if (event.eventName === 'user:created' && !event.body.timezone) {
    return {
      ...event,
      body: {
        ...event.body,
        timezone: 'UTC' // Default value
      }
    };
  }
  return event;
}
```

### Scenario 2: Restructuring Nested Data

```typescript
// Old format: flat structure
const oldEvent = {
  eventName: 'order:created',
  body: {
    street: '123 Main St',
    city: 'New York',
    state: 'NY',
    zip: '10001'
  }
};

// New format: nested structure
const newEvent = {
  eventName: 'order:created',
  body: {
    address: {
      street: '123 Main St',
      city: 'New York',
      state: 'NY',
      zip: '10001'
    }
  }
};

// Upcasting function
function upcastOrderCreated(event: any) {
  if (
    event.eventName === 'order:created' &&
    event.body.street // Old format
  ) {
    return {
      ...event,
      body: {
        address: {
          street: event.body.street,
          city: event.body.city,
          state: event.body.state,
          zip: event.body.zip
        }
      }
    };
  }
  return event;
}
```

### Scenario 3: Replacing Field Type

```typescript
// Old format: string price
const oldEvent = {
  eventName: 'product:priced',
  body: { price: '100.00' }
};

// New format: number price
const newEvent = {
  eventName: 'product:priced',
  body: { price: 100.00 }
};

// Upcasting with type conversion
function upcastProductPriced(event: any) {
  if (
    event.eventName === 'product:priced' &&
    typeof event.body.price === 'string'
  ) {
    return {
      ...event,
      body: {
        ...event.body,
        price: parseFloat(event.body.price)
      }
    };
  }
  return event;
}
```

### Scenario 4: Splitting Into Multiple Events

```typescript
// Old: single comprehensive event
const oldEvent = {
  eventName: 'user:updated',
  body: {
    email: 'new@example.com',
    name: 'John Doe',
    bio: 'Software Engineer'
  }
};

// New: separate events for different concerns
const newEvents = [
  { eventName: 'user:email_changed', body: { email: 'new@example.com' } },
  { eventName: 'user:profile_updated', body: { name: 'John Doe', bio: 'Software Engineer' } }
];

// Migration strategy: emit separate events during replay
function migrateUserUpdated(event: any): any[] {
  if (event.eventName === 'user:updated') {
    const events: any[] = [];

    if (event.body.email) {
      events.push({
        eventId: `${event.eventId}-email`,
        eventName: 'user:email_changed',
        body: { email: event.body.email },
        eventCreatedAt: event.eventCreatedAt
      });
    }

    if (event.body.name || event.body.bio) {
      events.push({
        eventId: `${event.eventId}-profile`,
        eventName: 'user:profile_updated',
        body: {
          name: event.body.name,
          bio: event.body.bio
        },
        eventCreatedAt: event.eventCreatedAt
      });
    }

    return events;
  }

  return [event];
}
```

## Migration Checklist

### Before Making Changes

- [ ] Document current event schema
- [ ] Identify all events needing changes
- [ ] Plan backward compatibility strategy
- [ ] Test migration with sample data
- [ ] Notify team of upcoming changes
- [ ] Update schema definitions
- [ ] Prepare rollback plan

### During Migration

- [ ] Deploy upcasting code first
- [ ] Monitor for errors
- [ ] Verify old and new events work
- [ ] Update documentation
- [ ] Record migration details

### After Migration

- [ ] Verify all systems work
- [ ] Monitor for issues
- [ ] Plan cleanup of old events (optional)
- [ ] Update team documentation
- [ ] Share learnings

## Best Practices

### Do's

```typescript
// Do: Provide default values for new fields
function upcast(event: any) {
  if (!event.body.timezone) {
    event.body.timezone = 'UTC'; // Safe default
  }
  return event;
}

// Do: Keep old event handlers in reducer
const reducer = (prevState, event) => {
  switch (event.eventName) {
    case 'user:created':
    case 'user:created_v2': // Support both
      return handleUserCreated(event);
    // ...
  }
};

// Do: Test migrations thoroughly
describe('Event Migration', () => {
  it('upcasts v1 to v2 correctly', () => {
    const oldEvent = { /* v1 */ };
    const upgraded = upcast(oldEvent);
    expect(upgraded).toMatchSnapshot();
  });
});

// Do: Document migration strategy
/**
 * User email migration strategy:
 * - V1: email as string
 * - V2: email in nested object
 * - Upcasting: automatic via upcastUserCreated()
 */
```

### Don'ts

```typescript
// Don't: Assume event structure
// BAD
const upcast = (event: any) => {
  event.body.timezone = 'UTC'; // Might break if event.body is undefined
};

// GOOD
const upcast = (event: any) => {
  return {
    ...event,
    body: {
      ...event.body,
      timezone: event.body?.timezone || 'UTC'
    }
  };
};

// Don't: Change event meaning
// BAD: This changes the semantic meaning
dispatch('order:created', { status: 'shipped' }); // Wrong!

// GOOD: Create new event
dispatch('order:shipped', { trackingNumber: '...' });

// Don't: Ignore backward compatibility
// BAD: Only support latest version
const reducer = (state, event) => {
  if (event.eventName === 'user:created_v2') {
    return { /* ... */ };
  }
};

// GOOD: Support all versions
const reducer = (state, event) => {
  if (event.eventName === 'user:created' ||
      event.eventName === 'user:created_v2') {
    return { /* ... */ };
  }
};
```

## Tools and Libraries

Consider using versioning libraries:

```typescript
// JSON Schema with versioning
import Ajv from 'ajv';

const eventSchemas = {
  'user:created:1': {
    /* v1 schema */
  },
  'user:created:2': {
    /* v2 schema */
  }
};

// Use schema validator with version
const ajv = new Ajv();
const validateEvent = ajv.compile({
  oneOf: Object.values(eventSchemas)
});
```

## Related Documentation

- [Best Practices](/docs/best-practices)
- [Error Handling](/docs/guides/error-handling)
- [Testing Guide](/docs/guides/testing)
