---
title: Reducers
description: Understanding reducers, pure functions, and best practices for state computation
---

# Reducers

Reducers are the heart of event sourcing. They're pure functions that compute your entity's state by replaying all events in order. Understanding how to write good reducers is crucial for building reliable event-sourced systems.

## What is a Reducer?

A reducer is a **pure function** that takes the current state and an event, and returns the new state:

```typescript
(previousState, event) => newState
```

```typescript
import { defineReducer } from 'ventyd';

const userReducer = defineReducer(userSchema, (prevState, event) => {
  switch (event.eventName) {
    case "user:created":
      return {
        name: event.body.name,
        email: event.body.email,
        bio: undefined
      };

    case "user:email_updated":
      return {
        ...prevState,
        email: event.body.email
      };

    case "user:bio_updated":
      return {
        ...prevState,
        bio: event.body.bio
      };

    default:
      return prevState;
  }
});
```

## How Reducers Work

State is computed by replaying events through the reducer:

```typescript
// Starting state is undefined
let state = undefined;

// Event 1: user:created
state = reducer(state, {
  eventName: "user:created",
  body: { name: "Alice", email: "alice@example.com" }
});
// state = { name: "Alice", email: "alice@example.com", bio: undefined }

// Event 2: user:email_updated
state = reducer(state, {
  eventName: "user:email_updated",
  body: { email: "alice2@example.com" }
});
// state = { name: "Alice", email: "alice2@example.com", bio: undefined }

// Event 3: user:bio_updated
state = reducer(state, {
  eventName: "user:bio_updated",
  body: { bio: "Software Engineer" }
});
// state = { name: "Alice", email: "alice2@example.com", bio: "Software Engineer" }
```

When you load an entity from the event store, Ventyd automatically replays all events:

```typescript
const user = await userRepository.findOne({ entityId: "user-123" });

// Internally, Ventyd did this:
// let state = undefined;
// for (const event of events) {
//   state = reducer(state, event);
// }

console.log(user.state); // The final computed state
```

## Pure Functions

Reducers must be **pure functions** - they have no side effects and always produce the same output for the same inputs:

### ✅ Pure Reducer

```typescript
// Pure - same input always produces same output
const userReducer = defineReducer(userSchema, (prevState, event) => {
  switch (event.eventName) {
    case "user:created":
      return {
        name: event.body.name,
        email: event.body.email
      };
    case "user:email_updated":
      return {
        ...prevState,
        email: event.body.email
      };
    default:
      return prevState;
  }
});
```

### ❌ Non-Pure Reducer (Don't Do This)

```typescript
// ❌ Side effects: calls external service
const badReducer = defineReducer(userSchema, (prevState, event) => {
  if (event.eventName === "user:created") {
    // Side effect - bad!
    sendWelcomeEmail(event.body.email);
  }
  return newState;
});

// ❌ Non-deterministic: uses current time
const badReducer = defineReducer(userSchema, (prevState, event) => {
  return {
    ...prevState,
    lastUpdateTime: new Date() // Current time - not deterministic!
  };
});

// ❌ Uses external state: depends on external variable
let counter = 0;
const badReducer = defineReducer(userSchema, (prevState, event) => {
  counter++; // Depends on external state
  return {
    ...prevState,
    updateCount: counter // Different every time!
  };
});

// ❌ Mutates input: modifies prevState directly
const badReducer = defineReducer(userSchema, (prevState, event) => {
  prevState.email = event.body.email; // Mutating!
  return prevState; // Same object - bad!
});
```

## Determinism

Reducers must be **deterministic** - replaying the same events always produces the same state:

```typescript
// ✅ Good - Deterministic
const reducer = (state, event) => {
  if (event.eventName === "order:created") {
    return {
      status: "pending",
      items: event.body.items,
      subtotal: calculateSubtotal(event.body.items) // Pure function
    };
  }
};

// ❌ Bad - Non-deterministic
const reducer = (state, event) => {
  if (event.eventName === "order:created") {
    return {
      status: "pending",
      items: event.body.items,
      processingTime: Date.now() // Changes every time!
    };
  }
};
```

Why determinism matters:

```typescript
// If reducer is deterministic:
const user1 = loadEntityFromEvents(events, reducer);
const user2 = loadEntityFromEvents(events, reducer);
console.log(user1.state === user2.state); // true ✅

// If reducer is non-deterministic:
const user1 = loadEntityFromEvents(events, reducer);
const user2 = loadEntityFromEvents(events, reducer);
console.log(user1.state === user2.state); // false ❌ Different times!
```

## Handling All Event Types

Your reducer should handle all possible events for the entity:

```typescript
const orderSchema = defineSchema("order", {
  schema: valibot({
    event: {
      created: v.object({ items: v.array(...) }),
      item_added: v.object({ productId: v.string() }),
      item_removed: v.object({ productId: v.string() }),
      status_updated: v.object({ status: v.enum(...) }),
      cancelled: v.object({ reason: v.optional(v.string()) })
    },
    state: v.object({ items: v.array(...), status: v.string() })
  })
});

const orderReducer = defineReducer(orderSchema, (prevState, event) => {
  switch (event.eventName) {
    // ✅ Good - Handle all events
    case "order:created":
      return {
        items: event.body.items,
        status: "pending"
      };
    case "order:item_added":
      return {
        ...prevState,
        items: [...prevState.items, event.body.item]
      };
    case "order:item_removed":
      return {
        ...prevState,
        items: prevState.items.filter(i => i.id !== event.body.id)
      };
    case "order:status_updated":
      return {
        ...prevState,
        status: event.body.status
      };
    case "order:cancelled":
      return {
        ...prevState,
        status: "cancelled"
      };
    // ✅ Always have a default case
    default:
      return prevState;
  }
});
```

<Callout type="warning">
**Important: Always include a default case**

```typescript
// ❌ Bad - Missing default case
const reducer = (state, event) => {
  switch (event.eventName) {
    case "user:created":
      return { ... };
    // No default - what happens if new event type?
  }
};

// ✅ Good - Always return prevState for unknown events
const reducer = (state, event) => {
  switch (event.eventName) {
    case "user:created":
      return { ... };
    default:
      return prevState; // Handle unknown events gracefully
  }
};
```
</Callout>

## Reducer Patterns

### Pattern 1: Simple State Update

```typescript
const userReducer = defineReducer(userSchema, (prevState, event) => {
  switch (event.eventName) {
    case "user:created":
      return {
        name: event.body.name,
        email: event.body.email
      };

    case "user:email_updated":
      return {
        ...prevState,
        email: event.body.email
      };

    default:
      return prevState;
  }
});
```

### Pattern 2: Array Manipulation

```typescript
const orderReducer = defineReducer(orderSchema, (prevState, event) => {
  switch (event.eventName) {
    case "order:created":
      return {
        items: event.body.items
      };

    case "order:item_added":
      return {
        ...prevState,
        items: [
          ...prevState.items,
          event.body.item
        ]
      };

    case "order:item_removed":
      return {
        ...prevState,
        items: prevState.items.filter(
          item => item.id !== event.body.itemId
        )
      };

    default:
      return prevState;
  }
});
```

### Pattern 3: Nested Object Updates

```typescript
const userReducer = defineReducer(userSchema, (prevState, event) => {
  switch (event.eventName) {
    case "user:created":
      return {
        profile: {
          name: event.body.name,
          email: event.body.email
        },
        settings: {
          theme: "light",
          notifications: true
        }
      };

    case "user:settings_updated":
      return {
        ...prevState,
        settings: {
          ...prevState.settings,
          ...event.body
        }
      };

    default:
      return prevState;
  }
});
```

### Pattern 4: Conditional Updates

```typescript
const subscriptionReducer = defineReducer(
  subscriptionSchema,
  (prevState, event) => {
    switch (event.eventName) {
      case "subscription:created":
        return {
          plan: event.body.plan,
          status: "active",
          startDate: event.eventCreatedAt
        };

      case "subscription:plan_changed":
        // Only allow if currently active
        if (prevState.status === "active") {
          return {
            ...prevState,
            plan: event.body.plan
          };
        }
        return prevState;

      default:
        return prevState;
    }
  }
);
```

### Pattern 5: Derived State

```typescript
const cartReducer = defineReducer(cartSchema, (prevState, event) => {
  switch (event.eventName) {
    case "cart:created":
      return {
        items: event.body.items,
        total: calculateTotal(event.body.items), // Derived
        itemCount: event.body.items.length       // Derived
      };

    case "cart:item_added":
      const newItems = [
        ...prevState.items,
        event.body.item
      ];
      return {
        items: newItems,
        total: calculateTotal(newItems),    // Recalculate
        itemCount: newItems.length          // Recalculate
      };

    default:
      return prevState;
  }
});
```

## Testing Reducers

Reducers are easy to test because they're pure functions:

```typescript
import { describe, it, expect } from 'vitest';

describe('userReducer', () => {
  it('should create user on user:created event', () => {
    const event = {
      eventName: "user:created",
      body: {
        name: "Alice",
        email: "alice@example.com"
      }
    };

    const state = userReducer(undefined, event);

    expect(state).toEqual({
      name: "Alice",
      email: "alice@example.com"
    });
  });

  it('should update email on user:email_updated event', () => {
    const prevState = {
      name: "Alice",
      email: "alice@example.com"
    };

    const event = {
      eventName: "user:email_updated",
      body: {
        email: "alice2@example.com"
      }
    };

    const state = userReducer(prevState, event);

    expect(state).toEqual({
      name: "Alice",
      email: "alice2@example.com"
    });
  });

  it('should return prevState for unknown events', () => {
    const prevState = { name: "Alice" };
    const event = {
      eventName: "unknown:event",
      body: {}
    };

    const state = userReducer(prevState, event);

    expect(state).toBe(prevState);
  });

  it('should replay events correctly', () => {
    const events = [
      { eventName: "user:created", body: { name: "Alice", email: "alice@example.com" } },
      { eventName: "user:email_updated", body: { email: "alice2@example.com" } },
      { eventName: "user:name_updated", body: { name: "Alice Smith" } }
    ];

    let state = undefined;
    for (const event of events) {
      state = userReducer(state, event);
    }

    expect(state).toEqual({
      name: "Alice Smith",
      email: "alice2@example.com"
    });
  });
});
```

## Common Mistakes

<Callout type="warning">
**❌ Mutating prevState directly**

```typescript
// Bad - Mutates the previous state
const reducer = (state, event) => {
  if (event.eventName === "user:email_updated") {
    state.email = event.body.email; // Mutating!
    return state;
  }
};

// Good - Creates new object
const reducer = (state, event) => {
  if (event.eventName === "user:email_updated") {
    return {
      ...state,
      email: event.body.email
    };
  }
};
```
</Callout>

<Callout type="warning">
**❌ Calling external services**

```typescript
// Bad - Side effect
const reducer = (state, event) => {
  if (event.eventName === "order:paid") {
    await processPayment(event.body); // Side effect!
  }
  return state;
};

// Good - Pure function, side effects in mutations
class Order extends Entity(schema, reducer) {
  pay = mutation(this, async (dispatch, paymentInfo) => {
    // Handle side effects here
    await processPayment(paymentInfo);
    // Then dispatch event
    dispatch("order:paid", { ... });
  });
}
```
</Callout>

<Callout type="warning">
**❌ Using non-deterministic data**

```typescript
// Bad - Uses current time (non-deterministic)
const reducer = (state, event) => {
  return {
    ...state,
    lastUpdate: new Date() // Different every time!
  };
};

// Good - Uses event timestamp (deterministic)
const reducer = (state, event) => {
  return {
    ...state,
    lastUpdate: event.eventCreatedAt // Fixed timestamp
  };
};
```
</Callout>

<Callout type="warning">
**❌ Missing default case**

```typescript
// Bad - Fails with new event types
const reducer = (state, event) => {
  switch (event.eventName) {
    case "order:created":
      return { ... };
    // Missing default - breaks with new events!
  }
};

// Good - Always handles unknown events
const reducer = (state, event) => {
  switch (event.eventName) {
    case "order:created":
      return { ... };
    default:
      return state; // Gracefully ignore unknown events
  }
};
```
</Callout>

## Best Practices

<Callout type="tip">
**1. Keep reducers simple**

Reducers should be easy to understand. If your reducer is complex, your events might not be granular enough.

```typescript
// Good - Simple, focused
case "order:status_updated":
  return { ...state, status: event.body.status };

// Too complex - might need smaller events
case "order:updated":
  // ... 50 lines of logic
```
</Callout>

<Callout type="tip">
**2. Avoid business logic in reducers**

Validation and business rules belong in mutations, not reducers:

```typescript
// Good - Reducer just updates state
case "user:created":
  return {
    name: event.body.name,
    email: event.body.email
  };

// Bad - Reducer doing validation
case "user:created":
  if (event.body.age < 18) throw new Error("Too young");
  // Validation should be in mutation, not reducer
```
</Callout>

<Callout type="tip">
**3. Use immutable updates**

Always create new objects, never mutate state:

```typescript
// Good - Spread operator creates new object
return {
  ...prevState,
  email: event.body.email
};

// Good - Array methods that create new array
return {
  ...prevState,
  items: [...prevState.items, newItem]
};

// Bad - Direct mutation
prevState.email = event.body.email;
return prevState;
```
</Callout>

<Callout type="tip">
**4. Snapshot large event streams**

For entities with thousands of events, implement snapshots to avoid replaying everything:

```typescript
// Load from snapshot + recent events (much faster)
const snapshot = await getSnapshot(entityId);
let state = snapshot.state;

const recentEvents = await getEventsAfter(
  entityId,
  snapshot.eventCount
);

for (const event of recentEvents) {
  state = reducer(state, event);
}
```

Ventyd handles this automatically in upcoming versions.
</Callout>

## Key Takeaways

- **Reducers compute state** by replaying events
- **Reducers must be pure** - no side effects, deterministic
- **Reducers must be deterministic** - same input = same output
- **Reducers should be simple** - focus on state transformation
- **Always have a default case** - handle unknown events gracefully
- **Never mutate prevState** - create new objects
- **Immutability is key** - events are immutable, state derivation must be pure

## Reducer Lifecycle

```
1. Schema defines possible events
   ↓
2. Reducer processes each event type
   ↓
3. State is computed by replaying
   ↓
4. Entity uses computed state
   ↓
5. When loading: replay all events
   ↓
6. When testing: pure function = easy test
```

<Callout type="info">
**Next Steps**

- [Events](/docs/core-concepts/events) - Design better events
- [Mutations](/docs/core-concepts/mutations) - Learn when to dispatch
- [Best Practices](/docs/best-practices) - More patterns
</Callout>
