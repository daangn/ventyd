---
title: Events
description: Understanding events, their structure, naming conventions, and design principles
---

# Events

Events are the foundation of event sourcing. They represent immutable facts about what happened in your system, and they're the source of truth for your application state.

## What is an Event?

An event is an immutable record that captures:
- **What happened**: The type of change (e.g., "user:created")
- **When it happened**: The timestamp (e.g., "2024-01-15T10:30:00Z")
- **Who it affected**: The entity ID (e.g., "user-123")
- **What changed**: The event body (e.g., name, email)

```typescript
{
  eventId: "evt_e7d3f4a2",
  eventName: "user:created",
  eventCreatedAt: "2024-01-15T10:30:00Z",
  entityName: "user",
  entityId: "user-123",
  body: {
    name: "Alice",
    email: "alice@example.com"
  }
}
```

## Event Structure

Every event in Ventyd has this structure:

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| **eventId** | string | Unique identifier | "evt_e7d3f4a2" |
| **eventName** | string | Type of change (namespaced) | "user:created" |
| **eventCreatedAt** | ISO 8601 | When event occurred | "2024-01-15T10:30:00Z" |
| **entityName** | string | Type of entity | "user" |
| **entityId** | string | Which entity changed | "user-123" |
| **body** | object | Change details | \{ name: "Alice", email: "..." \} |

### Example: Complete Event Lifecycle

```typescript
import { defineSchema } from 'ventyd';
import { valibot, v } from 'ventyd/valibot';

// Define what events can happen
const userSchema = defineSchema("user", {
  schema: valibot({
    event: {
      created: v.object({
        name: v.string(),
        email: v.pipe(v.string(), v.email())
      }),
      email_updated: v.object({
        email: v.pipe(v.string(), v.email())
      })
    },
    state: v.object({
      name: v.string(),
      email: v.string()
    })
  }),
  initialEventName: "user:created"
});

// Create entity
const user = User.create({
  body: {
    name: "Alice",
    email: "alice@example.com"
  }
});

// Internally, this creates:
// {
//   eventId: "evt_...",
//   eventName: "user:created",
//   eventCreatedAt: "2024-01-15T10:30:00Z",
//   entityName: "user",
//   entityId: "user-123",
//   body: { name: "Alice", email: "alice@example.com" }
// }

// Update email
user.updateEmail("newemail@example.com");

// Internally, this creates:
// {
//   eventId: "evt_...",
//   eventName: "user:email_updated",
//   eventCreatedAt: "2024-01-15T10:35:00Z",
//   entityName: "user",
//   entityId: "user-123",
//   body: { email: "newemail@example.com" }
// }
```

## Event Naming Conventions

Good event names are crucial for readability and understanding. Follow these conventions:

### Use Past Tense

Events describe things that **have already happened**:

```typescript
// ✅ Good - Past tense
"user:created"      // Something happened
"order:shipped"     // Something happened
"payment:received"  // Something happened

// ❌ Avoid - Imperative
"createUser"        // Sounds like a command
"shipOrder"         // Sounds like a command
"receivePayment"    // Sounds like a command
```

### Use Descriptive Names

Be specific about what happened:

```typescript
// ✅ Good - Specific
"order:item_added"
"subscription:upgraded"
"payment:failed"
"user:email_verified"

// ❌ Avoid - Vague
"order:updated"          // Updated what?
"user:changed"           // Changed what?
"notification:sent"      // What kind?
```

### Use Snake_case for Multi-word Event Names

```typescript
// ✅ Good
"subscription:plan_changed"
"user:password_reset"
"order:tracking_number_updated"

// ❌ Avoid
"subscription:planChanged"    // camelCase
"user:PASSWORD_RESET"         // ALL_CAPS
"order:tracking-number-updated"  // kebab-case
```

### Namespace Events by Entity

Always include the entity type:

```typescript
// ✅ Good - Clear namespace
"user:created"
"order:created"
"payment:received"

// ❌ Avoid - No namespace
"created"      // Created what?
"updated"      // Updated what?
"deleted"      // Deleted what?
```

## Defining Events in Your Schema

Events are defined in your schema:

```typescript
const orderSchema = defineSchema("order", {
  schema: valibot({
    event: {
      created: v.object({
        customerId: v.string(),
        items: v.array(v.object({
          productId: v.string(),
          quantity: v.pipe(v.number(), v.minValue(1)),
          price: v.pipe(v.number(), v.minValue(0))
        })),
        shippingAddress: v.object({
          street: v.string(),
          city: v.string(),
          zipCode: v.string()
        })
      }),
      item_added: v.object({
        productId: v.string(),
        quantity: v.pipe(v.number(), v.minValue(1)),
        price: v.pipe(v.number(), v.minValue(0))
      }),
      item_removed: v.object({
        productId: v.string()
      }),
      status_updated: v.object({
        status: v.enum(["pending", "confirmed", "shipped", "delivered"])
      }),
      cancelled: v.object({
        reason: v.optional(v.string())
      })
    },
    state: v.object({
      customerId: v.string(),
      items: v.array(v.object({
        productId: v.string(),
        quantity: v.number(),
        price: v.number()
      })),
      status: v.enum(["pending", "confirmed", "shipped", "delivered"]),
      shippingAddress: v.object({
        street: v.string(),
        city: v.string(),
        zipCode: v.string()
      })
    })
  }),
  initialEventName: "order:created"
});
```

Each event key becomes `{entityName}:{eventKey}`:
- `created` → `"order:created"`
- `item_added` → `"order:item_added"`
- `item_removed` → `"order:item_removed"`
- `status_updated` → `"order:status_updated"`
- `cancelled` → `"order:cancelled"`

## Event Design Principles

<Cards>
  <Card
    title="Immutability"
    description="Events never change once created"
  />
  <Card
    title="Completeness"
    description="Events contain all needed information to update state"
  />
  <Card
    title="Granularity"
    description="Each event represents one business fact"
  />
  <Card
    title="Traceability"
    description="Events record when, where, and why changes happen"
  />
</Cards>

### 1. Keep Events Immutable

Events are written once and never modified:

```typescript
// Events in the store are immutable
const user = await userRepository.findOne({ entityId: "user-123" });

// This event is part of history - it never changes
console.log(user.events[0]); // Sealed, immutable

// You can't update it
user.events[0].body.email = "new@example.com"; // ❌ Not the way

// Instead, create a new event
user.updateEmail("new@example.com"); // ✅ Creates new event
```

### 2. Include Complete Information

Events should contain everything needed to understand what happened:

```typescript
// ✅ Good - Complete information
dispatch("user:profile_updated", {
  name: "Alice Smith",
  email: "alice@example.com",
  bio: "Software Engineer"
});

// ❌ Avoid - Missing context
dispatch("user:updated", {
  changes: "name,email,bio"  // Need to look elsewhere to understand
});
```

### 3. Use Fine-Grained Events

Events should represent single business facts, not multiple unrelated changes:

```typescript
// ✅ Good - Separate events for different concerns
dispatch("order:item_added", { productId, quantity, price });
dispatch("order:shipping_address_updated", { address });
dispatch("order:status_updated", { status: "confirmed" });

// ❌ Avoid - Too much in one event
dispatch("order:updated", {
  items: [...],
  address: {...},
  status: "confirmed",
  // What actually changed?
});
```

**Why?**
- Each event is more understandable
- Easier to understand causality
- Better for debugging
- Simpler reducer logic

### 4. Make Events Describe Facts, Not Commands

Events describe what happened, not what you're asking to happen:

```typescript
// ✅ Good - Event describes what happened
dispatch("user:email_updated", { email: "new@example.com" });
dispatch("payment:processed", { amount: 100, currency: "USD" });
dispatch("subscription:cancelled", { reason: "User requested" });

// ❌ Avoid - Commands or questions
dispatch("update:email", { ... });  // Sounds like a command
dispatch("process:payment", { ... }); // Sounds like a command
dispatch("check:subscription", { ... }); // Sounds like a command
```

### 5. Record Additional Context

Include metadata that helps with debugging and auditing:

```typescript
// ✅ Good - Include context
dispatch("order:status_updated", {
  status: "shipped",
  trackingNumber: "TRACK123",
  carrier: "FedEx",
  estimatedDelivery: "2024-01-20"
});

// Better with event dispatching context
class Order extends Entity(orderSchema, orderReducer) {
  ship = mutation(this, (dispatch, trackingInfo) => {
    dispatch("order:shipped", {
      ...trackingInfo,
      shippedAt: new Date().toISOString()
    });
  });
}
```

## Event Examples by Domain

### E-commerce Domain

```typescript
// Product
"product:created"
"product:price_updated"
"product:inventory_adjusted"
"product:discontinued"

// Order
"order:created"
"order:item_added"
"order:item_removed"
"order:status_updated"
"order:paid"
"order:shipped"
"order:delivered"
"order:cancelled"

// Payment
"payment:initiated"
"payment:processed"
"payment:failed"
"payment:refunded"
```

### SaaS Domain

```typescript
// Subscription
"subscription:created"
"subscription:plan_changed"
"subscription:cancelled"
"subscription:paused"
"subscription:resumed"

// Account
"account:created"
"account:upgraded"
"account:downgraded"
"account:billing_address_updated"

// Usage
"usage:recorded"
"usage:quota_exceeded"
"usage:reset"
```

### Workflow Domain

```typescript
// Task
"task:created"
"task:assigned"
"task:started"
"task:completed"
"task:comment_added"
"task:deadline_changed"

// Project
"project:created"
"project:member_added"
"project:member_removed"
"project:archived"
```

## Validation Through the Schema

Events are validated when you define your schema:

```typescript
import { defineSchema } from 'ventyd';
import { valibot, v } from 'ventyd/valibot';

const userSchema = defineSchema("user", {
  schema: valibot({
    event: {
      created: v.object({
        // Email must be valid
        email: v.pipe(
          v.string(),
          v.email(),
          v.minLength(5),
          v.maxLength(255)
        ),
        // Name must be non-empty
        name: v.pipe(
          v.string(),
          v.minLength(1),
          v.maxLength(100)
        ),
        // Age has constraints
        age: v.optional(
          v.pipe(
            v.number(),
            v.minValue(13),
            v.maxValue(120)
          )
        )
      })
    },
    state: v.object({
      email: v.string(),
      name: v.string(),
      age: v.optional(v.number())
    })
  }),
  initialEventName: "user:created"
});

// When you dispatch, validation runs automatically
const user = User.create({
  body: {
    email: "alice@example.com", // ✅ Valid email
    name: "Alice",              // ✅ Valid name
    age: 28                      // ✅ Valid age
  }
});

// ❌ This would fail validation:
const user = User.create({
  body: {
    email: "not-an-email",      // ❌ Invalid email format
    name: "",                   // ❌ Empty name
    age: 5                       // ❌ Too young (< 13)
  }
});
```

## Event Versioning (Advanced)

As your schema evolves, you may need to handle different versions of events:

```typescript
// Version 1: Original schema
const userSchemaV1 = defineSchema("user", {
  schema: valibot({
    event: {
      created: v.object({
        email: v.string(),
        name: v.string()
      })
    },
    state: v.object({
      email: v.string(),
      name: v.string()
    })
  }),
  initialEventName: "user:created"
});

// Version 2: Added new field
const userSchemaV2 = defineSchema("user", {
  schema: valibot({
    event: {
      created: v.object({
        email: v.string(),
        name: v.string(),
        phone: v.optional(v.string()) // New field
      })
    },
    state: v.object({
      email: v.string(),
      name: v.string(),
      phone: v.optional(v.string())
    })
  }),
  initialEventName: "user:created"
});

// Handle migration in the reducer
const userReducer = defineReducer(userSchemaV2, (prevState, event) => {
  switch (event.eventName) {
    case "user:created":
      return {
        email: event.body.email,
        name: event.body.name,
        phone: event.body.phone || undefined // Default for old events
      };
  }
});
```

## Common Mistakes to Avoid

<Callout type="warning">
**❌ Storing too much context in event body**

Including unnecessary data bloats events:

```typescript
// Too much data
dispatch("order:shipped", {
  order: { ... },           // Don't store full order
  customer: { ... },        // Don't store full customer
  seller: { ... },          // Don't store full seller
  trackingNumber: "TRACK"   // Just store what changed
});

// Better
dispatch("order:shipped", {
  trackingNumber: "TRACK"   // Only what's needed
});
```
</Callout>

<Callout type="warning">
**❌ Creating a new event for every field change**

If multiple fields logically belong together, put them in one event:

```typescript
// Too granular
dispatch("user:name_updated", { firstName: "John" });
dispatch("user:name_updated", { lastName: "Doe" });
dispatch("user:email_updated", { email: "john@example.com" });
dispatch("user:phone_updated", { phone: "555-1234" });

// Better - logical grouping
dispatch("user:profile_updated", {
  firstName: "John",
  lastName: "Doe",
  email: "john@example.com",
  phone: "555-1234"
});
```
</Callout>

<Callout type="warning">
**❌ Using generic event names**

Vague names make history hard to understand:

```typescript
// Generic - what changed?
dispatch("order:updated", { ... });
dispatch("user:changed", { ... });

// Specific - clear what happened
dispatch("order:status_updated", { ... });
dispatch("user:email_verified", { ... });
```
</Callout>

## Key Takeaways

- **Events are immutable** facts about what happened
- **Events are complete** - they contain all needed information
- **Events are namespaced** - "entity:action" format
- **Events use past tense** - "user:created" not "createUser"
- **Events are fine-grained** - one business fact per event
- **Events are validated** - schema ensures data integrity
- **Events are the source of truth** - state is derived from them

## Event Lifecycle Summary

```
1. Define in schema
   ↓
2. Dispatch in mutation
   ↓
3. Validated against schema
   ↓
4. Stored in event store (immutable)
   ↓
5. Replayed by reducer to compute state
   ↓
6. Available for auditing and debugging
```

<Callout type="info">
**Next Steps**

- [Reducers](/docs/core-concepts/reducers) - Learn how events become state
- [Mutations](/docs/core-concepts/mutations) - Master event dispatching
- [Best Practices](/docs/best-practices) - More event design patterns
</Callout>
