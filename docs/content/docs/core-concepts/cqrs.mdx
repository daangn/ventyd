---
title: CQRS
description: Understanding Command Query Responsibility Segregation in event sourcing
---

# CQRS (Command-Query Responsibility Segregation)

CQRS is an architectural pattern that separates reading (queries) from writing (commands). When combined with event sourcing, it provides a powerful way to build scalable, maintainable systems. Ventyd uses CQRS through its entity loading mechanism.

## What is CQRS?

CQRS divides your application into two sides:

```
┌─────────────────────────────────┐
│        COMMAND (Write)          │
│   Create/Update/Delete          │
│   Entities dispatching events   │
│   Full validation               │
└─────────────────────────────────┘
           ▼
    Event Store (immutable)
           ▼
┌─────────────────────────────────┐
│         QUERY (Read)            │
│   Read current state            │
│   Load-only entities            │
│   No event dispatch             │
└─────────────────────────────────┘
```

Traditional systems treat reads and writes the same way:

```typescript
// Traditional CRUD - same model for reads and writes
const user = await userService.get(userId); // Read
user.name = "New Name";                      // Write
await userService.save(user);                // Save
```

With CQRS and event sourcing:

```typescript
// Commands (writes)
const user = await userRepository.findOne({ entityId: userId }); // Mutable
user.updateName("New Name");                                      // Dispatch event
await userRepository.commit(user);                                // Persist

// Queries (reads)
const userSnapshot = await getUserSnapshot(userId);             // Read
const readOnlyUser = User.load({
  entityId: userId,
  state: userSnapshot
});                                                              // Read-only
// Can't call mutations - type error
```

## Why CQRS?

<Cards>
  <Card
    title="Optimization"
    description="Read and write models can be optimized independently"
  />
  <Card
    title="Scalability"
    description="Serve more read requests with replicas or caches"
  />
  <Card
    title="Safety"
    description="Read-only entities prevent accidental mutations"
  />
  <Card
    title="Separation of Concerns"
    description="Clear distinction between commands and queries"
  />
  <Card
    title="Event Sourcing Integrity"
    description="Mutations must come from event history"
  />
  <Card
    title="Multiple Read Models"
    description="Create different optimized views of data"
  />
</Cards>

## Ventyd's CQRS Implementation

Ventyd enforces CQRS through entity loading modes:

### Command Side (Mutable)

Use `Entity.create()` or `repository.findOne()` for commands:

```typescript
import { Entity, mutation } from 'ventyd';

class User extends Entity(userSchema, userReducer) {
  updateEmail = mutation(this, (dispatch, email: string) => {
    if (!isValidEmail(email)) {
      throw new Error("Invalid email");
    }
    dispatch("user:email_updated", { email });
  });

  deactivate = mutation(this, (dispatch) => {
    dispatch("user:deactivated", {});
  });
}

// Command 1: Create new user
const newUser = User.create({
  body: {
    name: "Alice",
    email: "alice@example.com"
  }
});

newUser.updateEmail("alice2@example.com"); // ✅ Can call mutations
await userRepository.commit(newUser);

// Command 2: Load and update existing user
const user = await userRepository.findOne({ entityId: "user-123" });
user.deactivate(); // ✅ Can call mutations
await userRepository.commit(user);
```

### Query Side (Read-Only)

Use `Entity.load()` for queries:

```typescript
// Load entity from state snapshot (no events)
const userSnapshot = await cache.get(`user:${userId}`) ||
  await userRepository.findOne({ entityId: userId });

const readOnlyUser = User.load({
  entityId: userSnapshot.entityId,
  state: userSnapshot.state
});

// Can read state
console.log(readOnlyUser.state.name);
console.log(readOnlyUser.state.email);

// ❌ Cannot call mutations - TypeScript error
readOnlyUser.updateEmail("new@example.com");
// Error: Property 'updateEmail' does not exist on type 'User'
//        (when loaded with load())
```

## Real-World Example

### Typical Web Application

```typescript
import { createRepository } from 'ventyd';

// API Route: Get user profile (Query)
app.get('/api/users/:id', async (req, res) => {
  // Load from cache or snapshot
  const userSnapshot = await getUserSnapshot(req.params.id);

  // Create read-only entity
  const user = User.load({
    entityId: req.params.id,
    state: userSnapshot.state
  });

  // Send response
  res.json({
    name: user.state.name,
    email: user.state.email
  });
});

// API Route: Update user (Command)
app.put('/api/users/:id', async (req, res) => {
  try {
    // Load mutable entity with full history
    const user = await userRepository.findOne({
      entityId: req.params.id
    });

    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    // Execute commands
    if (req.body.name) {
      user.updateName(req.body.name);
    }
    if (req.body.email) {
      user.updateEmail(req.body.email);
    }

    // Persist
    await userRepository.commit(user);

    // Return updated state
    res.json(user.state);
  } catch (error) {
    res.status(400).json({
      error: error instanceof Error ? error.message : "Update failed"
    });
  }
});
```

## Separating Read and Write Models

### Write Model (Event-Sourced)

The write model is event-sourced and fully validated:

```typescript
class Order extends Entity(orderSchema, orderReducer) {
  // Commands
  addItem = mutation(this, (dispatch, item) => {
    // Validation
    if (this.state.status !== "pending") {
      throw new Error("Order is already " + this.state.status);
    }

    // Complex logic
    const existingItem = this.state.items.find(i => i.id === item.id);
    if (existingItem) {
      throw new Error("Item already in order");
    }

    // Event dispatch
    dispatch("order:item_added", item);
  });

  checkout = mutation(this, (dispatch) => {
    // Multiple validations
    if (this.state.items.length === 0) {
      throw new Error("Empty order");
    }
    if (!this.state.shippingAddress) {
      throw new Error("Shipping address required");
    }

    // Multiple events
    dispatch("order:confirmed", { confirmationNumber: generateNumber() });
    dispatch("order:payment_requested", { amount: calculateTotal() });
  });
}
```

### Read Model (Query-Optimized)

The read model is denormalized for fast access:

```typescript
// Read model structure (stored separately)
interface OrderReadModel {
  id: string;
  customerId: string;
  status: string;
  totalAmount: number;
  itemCount: number;
  lastUpdated: string;
  // Denormalized for fast queries
  customerName: string;
  shippingAddress: string;
  // Pre-calculated values
  estimatedDelivery: string;
}

// Query the read model (fast, no event replay)
async function getOrdersForCustomer(customerId: string) {
  return db.collection("orders_by_customer")
    .find({ customerId })
    .sort({ lastUpdated: -1 })
    .toArray();
}

// Serve as read-only entity
async function getOrderDetail(orderId: string) {
  const readModel = await getOrderReadModel(orderId);

  return Order.load({
    entityId: orderId,
    state: readModel.state
  });
}
```

### Synchronizing Models

Use plugins to update read model when write model changes:

```typescript
import type { Plugin } from 'ventyd';

const readModelPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    if (entityName !== "order") return;

    // Update read model collection
    await db.collection("orders_by_customer").updateOne(
      { _id: entityId },
      {
        $set: {
          ...state,
          customerName: await getCustomerName(state.customerId),
          estimatedDelivery: calculateDelivery(state.shippingAddress),
          lastUpdated: new Date().toISOString()
        }
      },
      { upsert: true }
    );

    // Update search index
    await searchEngine.index({
      id: entityId,
      type: "order",
      document: state
    });
  }
};

const orderRepository = createRepository(Order, {
  adapter,
  plugins: [readModelPlugin]
});
```

## Entity Loading Modes

| Mode | Method | Mutability | Use Case | Events | State |
|------|--------|-----------|----------|--------|-------|
| **Create** | `Entity.create()` | ✅ Mutable | New entities | Initial | Computed |
| **Hydrate** | `repository.findOne()` | ✅ Mutable | Load & modify | Full history | Computed |
| **Load** | `Entity.load()` | ❌ Read-only | Display/query | None | From snapshot |

## Type Safety in CQRS

TypeScript ensures you can't accidentally mutate read-only entities:

```typescript
// Mutable entity from repository
const user = await userRepository.findOne({ entityId: "user-123" });
user.updateEmail("new@example.com"); // ✅ Compiles - mutable

// Read-only entity from load()
const user = User.load({
  entityId: "user-123",
  state: { name: "Alice", email: "alice@example.com" }
});
user.updateEmail("new@example.com"); // ❌ Compile error - read-only
```

This is enforced at:
- **Compile time**: TypeScript catches the error
- **Runtime**: Error thrown if you bypass TypeScript

## Advanced: Making Loaded Entities Mutable

In specific scenarios, you may need to load an entity and mutate it anyway:

### Data Migration

```typescript
async function migrateUserData(oldUserId: string) {
  // Load from legacy system
  const legacyUser = await legacyDatabase.getUser(oldUserId);

  // Create mutable entity from legacy state
  const user = User.load({
    entityId: generateNewId(),
    state: {
      name: legacyUser.name,
      email: legacyUser.email
    },
    UNSAFE_mutable: true // Override read-only
  });

  // Can now dispatch migration events
  user.migrateFromLegacy();

  // Persist new entity
  await userRepository.commit(user);
}
```

### Testing with Specific State

```typescript
describe("Order mutations", () => {
  it("should prevent shipping of pending orders", () => {
    // Create test fixture
    const testOrder = Order.load({
      entityId: "test-order-123",
      state: {
        status: "pending",
        items: []
      },
      UNSAFE_mutable: true // For testing
    });

    // Test the behavior
    expect(() => {
      testOrder.ship({ trackingNumber: "TRACK123" });
    }).toThrow("Can only ship confirmed orders");
  });
});
```

### State Synchronization

```typescript
async function syncExternalSystemState(entityId: string, externalState: any) {
  // Load from external system
  const externalUser = User.load({
    entityId,
    state: {
      name: externalState.name,
      email: externalState.email
    },
    UNSAFE_mutable: true // Override for sync
  });

  // Dispatch events to sync
  externalUser.updateName(externalState.name);

  // Persist sync events
  await userRepository.commit(externalUser);
}
```

<Callout type="warning">
**⚠️ Warning: Use UNSAFE_mutable Carefully**

The `UNSAFE_` prefix indicates you're bypassing normal constraints. Only use when you understand the implications:

- **Safe uses**: Migration, testing, external sync
- **Unsafe uses**: Regular application logic, optimization attempts

If you find yourself using `UNSAFE_mutable` frequently, reconsider your architecture.
</Callout>

## Benefits of CQRS in Ventyd

### 1. Type Safety

```typescript
// Mutation only exists on mutable entities
const created = User.create({ body: {...} });
created.updateEmail("...");  // ✅ OK

const loaded = User.load({ entityId: "...", state: {...} });
loaded.updateEmail("...");   // ❌ Type error
```

### 2. Performance

```typescript
// Writes go through full validation
const user = await userRepository.findOne({ entityId: userId });
user.validateAndUpdate(...);
await userRepository.commit(user);

// Reads use optimized snapshots
const cached = cache.get(userId) ||
  await loadSnapshot(userId);
const readonly = User.load({ entityId: userId, state: cached });
// No event replay needed - instant
```

### 3. Scalability

```typescript
// Writes are handled by primary
await writeRepository.commit(entity);

// Reads are distributed across replicas
const snapshot1 = await readReplica1.getSnapshot(userId);
const snapshot2 = await readReplica2.getSnapshot(userId);
// Can scale reads independently
```

### 4. Event Sourcing Integrity

```typescript
// All mutations come from events
const user = await repository.findOne({ entityId });
user.updateName(...);  // Dispatch event

// Loaded entities can't mutate
const readonly = User.load({ ..., state });
readonly.updateName(...); // ❌ Can't bypass event history
```

## CQRS Patterns

### Pattern 1: Simple Query

```typescript
async function getUserProfile(userId: string) {
  const snapshot = await getSnapshot(userId);

  return User.load({
    entityId: userId,
    state: snapshot
  });
}
```

### Pattern 2: Complex Query (Denormalized Read Model)

```typescript
async function getCustomerWithOrders(customerId: string) {
  // Single denormalized query
  const result = await db.collection("customer_orders_view").findOne({
    customerId
  });

  return {
    customer: User.load({
      entityId: customerId,
      state: result.customer
    }),
    orders: result.orders.map(o =>
      Order.load({
        entityId: o.id,
        state: o.state
      })
    )
  };
}
```

### Pattern 3: Command with Event

```typescript
async function updateUserProfile(userId: string, updates: any) {
  // Load mutable
  const user = await userRepository.findOne({ entityId: userId });
  if (!user) throw new Error("Not found");

  // Execute command
  user.updateProfile(updates);

  // Persist
  await userRepository.commit(user);

  // Update read model async (via plugin)
  // Read model updated automatically

  return user.state;
}
```

## Key Takeaways

- **CQRS separates reads and writes** - different models, different optimization strategies
- **Ventyd enforces CQRS through loading** - `load()` returns read-only entities
- **Type safety prevents mistakes** - can't accidentally mutate read-only entities
- **Commands must use mutable entities** - creates/updates from event history
- **Queries use loaded entities** - fast, from snapshots
- **Plugins sync read models** - automatic update on write
- **Scalability improves** - reads and writes scale independently

## CQRS Workflow

```
Write Flow:
1. Load mutable entity (repository.findOne)
2. Execute mutations
3. Dispatch events
4. Commit to event store
5. Plugins update read models

Read Flow:
1. Load read-only entity (Entity.load from snapshot)
2. Access state
3. No event dispatch possible
4. Return data to client
```

## When to Use CQRS

<Callout type="tip">
**✅ Use CQRS when:**
- You have distinct read and write patterns
- Read load is much higher than write load
- You need multiple views of the same data
- You want clear separation of concerns
- You're using event sourcing anyway
</Callout>

<Callout type="warning">
**❌ CQRS might be overkill when:**
- Simple CRUD operations only
- Read and write loads are similar
- Small team (adds complexity)
- No need for multiple read models
</Callout>

<Callout type="info">
**Next Steps**

- [Repositories](/docs/core-concepts/repositories) - Manage persistence
- [Events](/docs/core-concepts/events) - Design your events
- [Best Practices](/docs/best-practices) - CQRS patterns and strategies
</Callout>
