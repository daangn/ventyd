---
title: Entities
description: Understanding entities, their lifecycle, and how to work with them
---

# Entities

Entities are the core building blocks of your domain model in Ventyd. They represent objects with a unique identity that persist over time and have business logic associated with them.

## What is an Entity?

An entity is a domain object that:
- Has a **unique identity** (`entityId`) that never changes
- Maintains **state** that evolves through events
- Encapsulates **business logic** through methods
- Can be **created, mutated, and persisted**

```typescript
// Example: User entity
class User extends Entity(userSchema, userReducer) {
  // Identity
  get id() {
    return this.entityId;
  }

  // State (derived from events)
  get name() {
    return this.state.name;
  }

  get email() {
    return this.state.email;
  }

  // Business logic (creates events)
  updateProfile = mutation(this, (dispatch, updates) => {
    dispatch("user:profile_updated", updates);
  });
}
```

## Entity Lifecycle

Entities have three distinct states:

### 1. Created Entities (Mutable)

Entities created with `Entity.create()` are mutable and can dispatch events:

```typescript
import { Entity, mutation } from 'ventyd';

// Create a new entity
const user = User.create({
  body: {
    name: "Alice",
    email: "alice@example.com"
  }
});

// The entity is mutable
console.log(user.state); // { name: "Alice", email: "alice@example.com" }
console.log(user.entityId); // auto-generated ID

// Can call mutations
user.updateProfile({ name: "Alice Smith" });

// Can commit to storage
await userRepository.commit(user);
```

<Callout type="info">
**Auto-generated IDs**

By default, Ventyd generates UUIDs for `entityId`. You can customize this in your configuration if needed.
</Callout>

### 2. Hydrated Entities (Mutable)

Entities loaded from the event store using `findOne()` are hydrated from their events and remain mutable:

```typescript
// Retrieve and reconstruct from events
const user = await userRepository.findOne({
  entityId: "user-123"
});

// State is reconstructed by replaying all events
console.log(user.state); // Full current state
console.log(user.entityId); // "user-123"

// Events are available for inspection
console.log(user.events); // All events that created this state

// Hydrated entities are still mutable
user.updateProfile({ name: "New Name" });
await userRepository.commit(user);
```

Hydrated entities are useful for:
- **Reading and modifying existing entities**: Load from storage, make changes, save
- **Continuing workflows**: Load an order, add items, update status
- **Reactive updates**: Modify based on external events or user input

### 3. Loaded Entities (Read-Only)

Entities loaded from snapshots or state snapshots using `Entity.load()` are **read-only** and cannot dispatch events:

```typescript
// Load from a state snapshot (without events)
const user = User.load({
  entityId: "user-123",
  state: {
    name: "Bob",
    email: "bob@example.com"
  }
});

// State is available
console.log(user.state); // { name: "Bob", email: "bob@example.com" }
console.log(user.entityId); // "user-123"

// ❌ Cannot dispatch events - TypeScript error
user.updateProfile({ name: "Robert" });
// Error: Property 'updateProfile' does not exist
```

This enforces **Command-Query Responsibility Segregation (CQRS)** - loaded entities are purely for reading.

## Entity Creation

### Using `Entity.create()`

Create a new entity:

```typescript
const user = User.create({
  body: {
    name: "Charlie",
    email: "charlie@example.com"
  }
});

console.log(user.entityId); // Generated ID
console.log(user.state); // { name: "Charlie", email: "charlie@example.com" }
console.log(user.events); // [{ eventName: "user:created", ... }]
```

The entity starts with:
- An auto-generated `entityId`
- State computed from the initial event
- An empty event history (only the creation event)

### Using `Entity.load()`

Load from a state snapshot (read-only):

```typescript
const user = User.load({
  entityId: "user-456",
  state: {
    name: "Diana",
    email: "diana@example.com"
  }
});

// This is read-only - cannot mutate
user.state; // Available
user.entityId; // Available
// user.updateProfile(...); // ❌ Error
```

### Hydration from Repository

Retrieve from event store:

```typescript
const user = await userRepository.findOne({
  entityId: "user-789"
});

// Fully hydrated - reconstructed from events
console.log(user.events); // All historical events
console.log(user.state); // Current state

// This is mutable
user.updateProfile({ name: "Updated" });
```

## The Three Ways: Create vs Load vs Hydrate

| Aspect | Create | Load | Hydrate |
|--------|--------|------|---------|
| **Creation Method** | `Entity.create()` | `Entity.load()` | `repository.findOne()` |
| **Source** | Initial event | State snapshot | Event store |
| **Mutability** | ✅ Mutable | ❌ Read-only | ✅ Mutable |
| **Use Case** | New entities | Display/read | Modify existing |
| **Events** | Initial event only | No events | Full history |

## Understanding Mutability

<Callout type="info">
**Why this matters for CQRS**

Ventyd's type system prevents loaded entities from mutating. This enforces the CQRS pattern:
- **Commands** (writes): Use created or hydrated entities
- **Queries** (reads): Use loaded entities
</Callout>

### Mutable Entities

Created and hydrated entities can dispatch events:

```typescript
class Order extends Entity(orderSchema, orderReducer) {
  addItem = mutation(this, (dispatch, item) => {
    dispatch("order:item_added", item);
  });
}

// Can mutate
const order = Order.create({ body: { items: [] } });
order.addItem({ productId: "prod-1", quantity: 2 });

// Can mutate
const existingOrder = await orderRepository.findOne({ entityId: "order-123" });
existingOrder.addItem({ productId: "prod-2", quantity: 1 });
```

### Read-Only Entities

Loaded entities cannot dispatch events:

```typescript
// Load for display (read-only)
const loadedOrder = Order.load({
  entityId: "order-123",
  state: { items: [...] }
});

// ❌ Cannot dispatch
loadedOrder.addItem({ ... }); // Type error
```

## Making Loaded Entities Mutable (Advanced)

In specific scenarios, you may need to load an entity and still mutate it. Use the `UNSAFE_mutable` option:

```typescript
// Load as mutable (for migrations, state sync, etc)
const mutableOrder = Order.load({
  entityId: "order-123",
  state: {
    items: [],
    status: "pending"
  },
  UNSAFE_mutable: true
});

// Now you can mutate
mutableOrder.addItem({ productId: "prod-1", quantity: 1 });
await orderRepository.commit(mutableOrder);
```

<Callout type="warning">
**⚠️ Use with Caution**

The `UNSAFE_` prefix indicates you're bypassing normal constraints. Only use in these scenarios:
- **Data migrations**: Loading from legacy systems
- **Testing**: Creating test fixtures with specific states
- **State synchronization**: Syncing state from external sources

Not recommended for normal application logic.
</Callout>

## Accessing Entity State

State is immutable and accessed through properties:

```typescript
class User extends Entity(userSchema, userReducer) {
  // Direct access
  get name() {
    return this.state.name;
  }

  get email() {
    return this.state.email;
  }

  // Computed properties
  get isActive() {
    return this.state.deactivatedAt === null;
  }

  get displayName() {
    return this.state.nickname || this.state.name;
  }
}

const user = await userRepository.findOne({ entityId: "user-123" });

console.log(user.name); // "Alice"
console.log(user.email); // "alice@example.com"
console.log(user.isActive); // true
console.log(user.displayName); // "alice" or full name
```

Never modify state directly:

```typescript
// ❌ Don't do this
user.state.name = "Bob"; // Doesn't work - state is frozen

// ✅ Use mutations instead
user.updateName("Bob");
```

## Accessing Entity Events

View the complete history:

```typescript
const user = await userRepository.findOne({ entityId: "user-123" });

// Access all events
user.events.forEach((event) => {
  console.log(`${event.eventCreatedAt}: ${event.eventName}`);
  console.log("  ", event.body);
});

// Output:
// 2024-01-15T10:00:00Z: user:created
//   { name: "Alice", email: "alice@example.com" }
// 2024-01-16T14:30:00Z: user:name_updated
//   { name: "Alice Smith" }
```

<Callout type="info">
**Events availability**

- **Created entities**: Only have the creation event
- **Hydrated entities**: Have complete event history
- **Loaded entities**: Have no events (loaded from snapshot)
</Callout>

## Entity Identity

Each entity has a unique `entityId`:

```typescript
const user = User.create({
  body: { name: "Eve", email: "eve@example.com" }
});

console.log(user.entityId); // Unique identifier

// Identity never changes
const same = await userRepository.findOne({
  entityId: user.entityId
});

console.log(same.entityId === user.entityId); // true
```

Entity identity is crucial for:
- **Persistence**: Finding the entity in storage
- **References**: Linking entities together
- **Immutability**: The ID never changes even if state changes

## Common Patterns

### Pattern 1: Create and Persist

```typescript
async function createNewUser(data: CreateUserInput) {
  // Create
  const user = User.create({
    body: { name: data.name, email: data.email }
  });

  // Persist
  await userRepository.commit(user);

  // Return
  return user;
}
```

### Pattern 2: Load and Update

```typescript
async function updateUserProfile(userId: string, updates: UpdateInput) {
  // Load
  const user = await userRepository.findOne({ entityId: userId });
  if (!user) throw new Error("User not found");

  // Update
  user.updateProfile(updates);

  // Persist
  await userRepository.commit(user);

  // Return updated entity
  return user;
}
```

### Pattern 3: Load for Display

```typescript
async function getUserProfile(userId: string) {
  // Load from snapshot for fast display
  const userSnapshot = await cache.getOrFetch(
    `user:${userId}`,
    () => userRepository.findOne({ entityId: userId })
  );

  // Convert to read-only for display
  const displayUser = User.load({
    entityId: userId,
    state: userSnapshot.state
  });

  return displayUser;
}
```

### Pattern 4: Access Event History

```typescript
async function getUserTimeline(userId: string) {
  const user = await userRepository.findOne({ entityId: userId });

  // Build timeline from events
  return user.events.map((event) => ({
    time: event.eventCreatedAt,
    action: event.eventName.split(":")[1],
    details: event.body
  }));
}
```

## Best Practices

<Callout type="tip">
**1. Use getters for state access**

Don't access `state` directly. Create getter methods for cleaner code:

```typescript
// Good
get isDeleted() {
  return this.state.deletedAt !== null;
}

// Less good
if (user.state.deletedAt !== null) { ... }
```
</Callout>

<Callout type="tip">
**2. Always validate in mutations**

Check business rules before dispatching events:

```typescript
updateProfile = mutation(this, (dispatch, updates) => {
  // Validate
  if (this.isDeleted) {
    throw new Error("Cannot update deleted user");
  }

  // Then dispatch
  dispatch("user:profile_updated", updates);
});
```
</Callout>

<Callout type="tip">
**3. Use hydration for persistence**

Load entities from `repository.findOne()` when you need to modify them:

```typescript
// Good - Load and modify
const user = await userRepository.findOne({ entityId: userId });
user.updateName("New Name");
await userRepository.commit(user);

// Less good - Load snapshot and try to mutate
const snapshot = await getSnapshot(userId);
// Can't mutate - it's read-only!
```
</Callout>

## Key Takeaways

- **Entities** are domain objects with identity and behavior
- **Create** entities with `Entity.create()` (mutable)
- **Load** entities with `Entity.load()` (read-only, for CQRS)
- **Hydrate** entities with `repository.findOne()` (mutable, with history)
- State is **derived** from events and accessed through getters
- Use **mutations** to change state, never modify directly
- Understand the **CQRS pattern**: reads use loaded entities, writes use created/hydrated

<Callout type="info">
**Next Steps**

- [Events](/docs/core-concepts/events) - Learn about event structure and design
- [Mutations](/docs/core-concepts/mutations) - Master how to safely change state
- [Repositories](/docs/core-concepts/repositories) - Understand persistence
</Callout>
