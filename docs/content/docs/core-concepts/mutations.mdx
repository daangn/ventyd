---
title: Mutations
description: Understanding mutations, how to safely dispatch events, and validation
---

# Mutations

Mutations are the only way to change an entity's state in Ventyd. They encapsulate business logic, validate rules, and dispatch events. Understanding mutations is crucial to building safe, maintainable event-sourced systems.

## What is a Mutation?

A mutation is a method on an entity that:
1. **Validates** business rules
2. **Dispatches** events to change state
3. **Ensures safety** through the `mutation()` helper

```typescript
import { Entity, mutation } from 'ventyd';

class User extends Entity(userSchema, userReducer) {
  // A mutation
  updateEmail = mutation(this, (dispatch, email: string) => {
    // 1. Validate
    if (!isValidEmail(email)) {
      throw new Error("Invalid email format");
    }

    // 2. Dispatch
    dispatch("user:email_updated", { email });
  });
}
```

## The `mutation()` Helper

The `mutation()` helper provides several important features:

```typescript
import { mutation } from 'ventyd';

updateProfile = mutation(
  this,                    // Bind to entity instance
  (dispatch, name: string) => {  // Function that dispatches events
    // Your mutation logic
  }
);
```

<Cards>
  <Card
    title="Type Safety"
    description="Prevents read-only entities from mutating"
  />
  <Card
    title="Validation"
    description="Check business rules before dispatching"
  />
  <Card
    title="Context"
    description="Access entity state with 'this'"
  />
  <Card
    title="Dispatch Binding"
    description="Automatically binds dispatch to entity"
  />
</Cards>

## Creating Mutations

### Basic Mutation

```typescript
class User extends Entity(userSchema, userReducer) {
  updateEmail = mutation(this, (dispatch, email: string) => {
    dispatch("user:email_updated", { email });
  });
}

// Usage
const user = User.create({
  body: { name: "Alice", email: "alice@example.com" }
});

user.updateEmail("newemail@example.com");
```

### Mutation with Validation

```typescript
class User extends Entity(userSchema, userReducer) {
  updateEmail = mutation(this, (dispatch, email: string) => {
    // Validate format
    if (!email.includes("@")) {
      throw new Error("Invalid email format");
    }

    // Validate business rule (access state with 'this')
    if (this.state.email === email) {
      throw new Error("Email is already set to this value");
    }

    // Dispatch
    dispatch("user:email_updated", { email });
  });
}
```

### Mutation with Complex Validation

```typescript
class Order extends Entity(orderSchema, orderReducer) {
  addItem = mutation(
    this,
    (dispatch, item: { productId: string; quantity: number; price: number }) => {
      // Validate item
      if (item.quantity <= 0) {
        throw new Error("Quantity must be positive");
      }

      if (item.price < 0) {
        throw new Error("Price cannot be negative");
      }

      // Validate entity state
      if (this.state.status !== "pending") {
        throw new Error("Can only add items to pending orders");
      }

      // Check business rules
      const existingItem = this.state.items.find(
        i => i.productId === item.productId
      );

      if (existingItem) {
        throw new Error("Item already in order");
      }

      // All checks passed - dispatch
      dispatch("order:item_added", item);
    }
  );
}
```

## Mutation Examples by Domain

### E-commerce

```typescript
class Product extends Entity(productSchema, productReducer) {
  updatePrice = mutation(this, (dispatch, newPrice: number) => {
    if (newPrice < 0) {
      throw new Error("Price cannot be negative");
    }

    if (newPrice === this.state.price) {
      throw new Error("Price is unchanged");
    }

    dispatch("product:price_updated", { newPrice });
  });

  discontinue = mutation(this, (dispatch, reason?: string) => {
    if (this.state.discontinued) {
      throw new Error("Already discontinued");
    }

    dispatch("product:discontinued", { reason });
  });
}

class Order extends Entity(orderSchema, orderReducer) {
  ship = mutation(this, (dispatch, trackingNumber: string) => {
    if (this.state.status !== "confirmed") {
      throw new Error("Order must be confirmed before shipping");
    }

    if (!trackingNumber) {
      throw new Error("Tracking number is required");
    }

    dispatch("order:shipped", { trackingNumber });
  });

  cancel = mutation(this, (dispatch, reason?: string) => {
    const nonCancellableStatuses = ["shipped", "delivered", "cancelled"];
    if (nonCancellableStatuses.includes(this.state.status)) {
      throw new Error(`Cannot cancel ${this.state.status} order`);
    }

    dispatch("order:cancelled", { reason });
  });
}
```

### SaaS/Subscriptions

```typescript
class Subscription extends Entity(subscriptionSchema, subscriptionReducer) {
  upgrade = mutation(this, (dispatch, newPlan: string) => {
    if (this.state.status !== "active") {
      throw new Error("Can only upgrade active subscriptions");
    }

    const plans = ["free", "pro", "enterprise"];
    const currentIndex = plans.indexOf(this.state.plan);
    const newIndex = plans.indexOf(newPlan);

    if (newIndex <= currentIndex) {
      throw new Error("Upgrade must be to a higher tier");
    }

    dispatch("subscription:plan_upgraded", { newPlan });
  });

  cancel = mutation(this, (dispatch, reason?: string) => {
    if (this.state.status === "cancelled") {
      throw new Error("Already cancelled");
    }

    dispatch("subscription:cancelled", { reason });
  });

  renew = mutation(this, (dispatch) => {
    if (this.state.status !== "expired") {
      throw new Error("Can only renew expired subscriptions");
    }

    dispatch("subscription:renewed", {});
  });
}
```

### Workflow/Tasks

```typescript
class Task extends Entity(taskSchema, taskReducer) {
  assign = mutation(this, (dispatch, assigneeId: string) => {
    if (this.state.status === "completed") {
      throw new Error("Cannot assign completed task");
    }

    if (this.state.assigneeId === assigneeId) {
      throw new Error("Already assigned to this user");
    }

    dispatch("task:assigned", { assigneeId });
  });

  start = mutation(this, (dispatch) => {
    if (this.state.status !== "todo") {
      throw new Error("Can only start todo tasks");
    }

    dispatch("task:started", { startedAt: new Date().toISOString() });
  });

  complete = mutation(this, (dispatch) => {
    if (this.state.status !== "in_progress") {
      throw new Error("Can only complete in-progress tasks");
    }

    dispatch("task:completed", { completedAt: new Date().toISOString() });
  });

  addComment = mutation(this, (dispatch, comment: string) => {
    if (!comment.trim()) {
      throw new Error("Comment cannot be empty");
    }

    if (this.state.status === "completed") {
      throw new Error("Cannot comment on completed task");
    }

    dispatch("task:comment_added", { comment });
  });
}
```

## Multiple Events from One Mutation

Sometimes a single business operation needs to dispatch multiple events:

```typescript
class Order extends Entity(orderSchema, orderReducer) {
  checkout = mutation(this, (dispatch) => {
    // Validate
    if (this.state.items.length === 0) {
      throw new Error("Cannot checkout empty order");
    }

    if (!this.state.shippingAddress) {
      throw new Error("Shipping address required");
    }

    // Dispatch multiple events
    dispatch("order:confirmed", {
      confirmationNumber: generateNumber()
    });

    dispatch("order:payment_charged", {
      amount: calculateTotal(this.state.items),
      currency: "USD"
    });

    dispatch("order:status_updated", {
      status: "confirmed"
    });
  });
}
```

<Callout type="info">
**Atomicity Note**

All dispatches within a mutation are treated as a single atomic operation when committed. Either all succeed together or all fail together.

```typescript
await orderRepository.commit(order);
// All events from all mutations are persisted atomically
```
</Callout>

## Async Mutations

Mutations can be async for operations that need to validate against external systems:

```typescript
class User extends Entity(userSchema, userReducer) {
  verifyEmail = mutation(this, async (dispatch, email: string) => {
    // Validate
    if (!email.includes("@")) {
      throw new Error("Invalid email");
    }

    // External validation (can be async)
    const isAvailable = await checkEmailAvailable(email);
    if (!isAvailable) {
      throw new Error("Email already in use");
    }

    // Dispatch
    dispatch("user:email_verified", { email });
  });
}

// Usage (must be awaited)
await user.verifyEmail("new@example.com");
```

<Callout type="warning">
**Important: Async side effects**

Mutations are the right place for async validation, but not for side effects that shouldn't block:

```typescript
// ✅ Good - Validation before dispatch
verifyEmail = mutation(this, async (dispatch, email) => {
  const exists = await checkEmailExists(email);
  if (exists) throw new Error("Email taken");
  dispatch("user:email_verified", { email });
});

// ❌ Bad - Side effects that block
verifyEmail = mutation(this, async (dispatch, email) => {
  dispatch("user:email_verified", { email });
  // Don't do this - blocks the mutation
  await sendVerificationEmail(email);
});

// ✅ Better - Use plugins for post-commit side effects
const emailPlugin: Plugin = {
  async onCommitted({ events }) {
    const verified = events.find(e => e.eventName === "user:email_verified");
    if (verified) {
      await sendVerificationEmail(verified.body.email);
    }
  }
};
```
</Callout>

## Accessing State in Mutations

Use `this` to access the entity's state:

```typescript
class Account extends Entity(accountSchema, accountReducer) {
  transfer = mutation(this, (dispatch, amount: number, targetAccountId: string) => {
    // Access current state
    if (amount > this.state.balance) {
      throw new Error("Insufficient funds");
    }

    if (amount <= 0) {
      throw new Error("Amount must be positive");
    }

    // Access entity identity
    console.log(`Transferring from ${this.entityId}`);

    // Dispatch
    dispatch("account:transfer_initiated", {
      targetAccountId,
      amount
    });
  });

  getAvailableBalance = () => {
    // You can also have regular methods
    return Math.max(0, this.state.balance - this.state.reserved);
  };
}
```

## Type-Safe Mutations

TypeScript ensures mutations are type-safe:

```typescript
const user = User.create({
  body: { name: "Alice", email: "alice@example.com" }
});

// ✅ TypeScript knows updateEmail exists
user.updateEmail("new@example.com");

// ❌ TypeScript error - method doesn't exist
user.updateAge(25);

// ✅ TypeScript checks parameter types
user.updateEmail("newemail@example.com"); // string ✅

// ❌ TypeScript error - wrong type
user.updateEmail(123); // number ❌
```

## Read-Only Entities Cannot Mutate

Remember: loaded entities are read-only and cannot dispatch:

```typescript
// Created entity - can mutate
const user = User.create({
  body: { name: "Alice", email: "alice@example.com" }
});
user.updateEmail("new@example.com"); // ✅ Works

// Hydrated entity - can mutate
const user = await userRepository.findOne({ entityId: "user-123" });
user.updateEmail("new@example.com"); // ✅ Works

// Loaded entity - read-only
const user = User.load({
  entityId: "user-123",
  state: { name: "Alice", email: "alice@example.com" }
});
user.updateEmail("new@example.com"); // ❌ Type error
```

## Testing Mutations

Mutations are easy to test:

```typescript
import { describe, it, expect } from 'vitest';

describe('User mutations', () => {
  it('should update email', () => {
    const user = User.create({
      body: { name: "Alice", email: "alice@example.com" }
    });

    user.updateEmail("newemail@example.com");

    expect(user.state.email).toBe("newemail@example.com");
    expect(user.events).toHaveLength(2); // create + update
  });

  it('should throw on invalid email', () => {
    const user = User.create({
      body: { name: "Alice", email: "alice@example.com" }
    });

    expect(() => {
      user.updateEmail("not-an-email");
    }).toThrow("Invalid email");
  });

  it('should throw if email unchanged', () => {
    const user = User.create({
      body: { name: "Alice", email: "alice@example.com" }
    });

    expect(() => {
      user.updateEmail("alice@example.com");
    }).toThrow("Email is already set");
  });

  it('should only allow updates on active accounts', () => {
    const user = User.create({
      body: { name: "Alice", email: "alice@example.com", status: "active" }
    });

    user.deactivate();
    // Now status is "inactive"

    expect(() => {
      user.updateEmail("new@example.com");
    }).toThrow("Cannot update inactive account");
  });
});
```

## Mutation Patterns

### Pattern 1: Guard Clause

```typescript
deleteAccount = mutation(this, (dispatch, reason: string) => {
  if (this.state.isDeleted) {
    throw new Error("Already deleted");
  }

  dispatch("account:deleted", { reason });
});
```

### Pattern 2: State-Based Actions

```typescript
complete = mutation(this, (dispatch) => {
  if (this.state.status !== "pending") {
    throw new Error(`Can't complete ${this.state.status} task`);
  }

  dispatch("task:completed", {});
});
```

### Pattern 3: Related Data Validation

```typescript
addMember = mutation(this, (dispatch, userId: string) => {
  // Check if already a member
  if (this.state.members.includes(userId)) {
    throw new Error("User already a member");
  }

  dispatch("team:member_added", { userId });
});
```

### Pattern 4: External Validation

```typescript
associateCard = mutation(this, async (dispatch, cardToken: string) => {
  // Validate with external service
  const card = await paymentService.validateCard(cardToken);
  if (!card.isValid) {
    throw new Error("Invalid card");
  }

  dispatch("account:card_added", { cardToken });
});
```

## Error Handling in Mutations

Throw meaningful errors:

```typescript
class Order extends Entity(orderSchema, orderReducer) {
  ship = mutation(this, (dispatch, trackingNumber: string) => {
    // Validate inputs
    if (!trackingNumber?.trim()) {
      throw new Error("Tracking number is required");
    }

    // Validate state
    if (this.state.status !== "confirmed") {
      throw new Error(
        `Cannot ship order with status "${this.state.status}". ` +
        `Order must be confirmed first.`
      );
    }

    // Validate business logic
    if (this.state.items.length === 0) {
      throw new Error("Cannot ship empty order");
    }

    // All validations passed
    dispatch("order:shipped", { trackingNumber });
  });
}
```

<Callout type="tip">
**Use custom error types for programmatic handling**

```typescript
class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

class BusinessRuleError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'BusinessRuleError';
  }
}

ship = mutation(this, (dispatch, trackingNumber) => {
  if (!trackingNumber) {
    throw new ValidationError("Tracking number required");
  }

  if (this.state.status !== "confirmed") {
    throw new BusinessRuleError(
      "Order must be confirmed before shipping"
    );
  }

  dispatch("order:shipped", { trackingNumber });
});
```
</Callout>

## Key Takeaways

- **Mutations are the only way to change state** - no direct state modification
- **Mutations validate before dispatching** - business rules are enforced
- **Use the `mutation()` helper** - provides type safety and binding
- **Access state with `this`** - for validation and context
- **Dispatch events, not state changes** - let the reducer compute new state
- **Throw meaningful errors** - validation failures should be clear
- **Read-only entities can't mutate** - enforces CQRS pattern
- **Test mutations easily** - they're just functions

## Mutation Workflow

```
1. Mutation is called
   ↓
2. Validate business rules
   ↓
3. Check entity state with 'this'
   ↓
4. Throw if invalid
   ↓
5. Dispatch event(s)
   ↓
6. Reducer computes new state
   ↓
7. Entity state updated
```

<Callout type="info">
**Next Steps**

- [Events](/docs/core-concepts/events) - Learn event design
- [Repositories](/docs/core-concepts/repositories) - Persist mutations
- [Reducers](/docs/core-concepts/reducers) - Understand state computation
</Callout>
