---
title: Performance Optimization
description: Optimize event-sourced systems with snapshots, caching, and batch operations
---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

## Overview

Event sourcing can impact performance when dealing with entities that have thousands of events. This guide covers optimization strategies to keep your system fast.

## The Performance Challenge

Event sourcing requires replaying all events to reconstruct state. With thousands of events, this can become slow. The strategies below help you optimize performance while maintaining data integrity.

## Optimization Strategies

<Accordions>
  <Accordion title="Strategy 1: Snapshots">
    Cache entity state at intervals to skip replaying old events.

    ```typescript
    interface SnapshotAdapter extends Adapter {
      getSnapshot?(
        entityName: string,
        entityId: string
      ): Promise<{ state: any; versionAsOf: string } | null>;

      saveSnapshot?(
        entityName: string,
        entityId: string,
        state: any,
        versionAsOf: string
      ): Promise<void>;
    }
    ```

    **When to snapshot:**
    - Every 100-500 events
    - On every write (for hot entities)
    - During off-peak hours (batch)

    **Performance gains:**
    - 1000 events: 100-500ms → 10-50ms
    - Reduces CPU usage by 90%+
    - Faster response times
  </Accordion>

  <Accordion title="Strategy 2: Caching">
    Cache loaded entity state to avoid repeated loads.

    ```typescript
    import NodeCache from 'node-cache';

    const cache = new NodeCache({ stdTTL: 3600 });

    async function findOneWithCache(entityName: string, entityId: string) {
      const key = `${entityName}:${entityId}`;

      // Check cache first
      const cached = cache.get(key);
      if (cached) return cached;

      // Load and cache
      const entity = await loadEntity(entityName, entityId);
      cache.set(key, entity.state);
      return entity;
    }
    ```

    **Invalidate cache with plugins:**
    ```typescript
    const cachePlugin: Plugin = {
      async onCommitted({ entityName, entityId }) {
        cache.del(`${entityName}:${entityId}`);
      }
    };
    ```
  </Accordion>

  <Accordion title="Strategy 3: Batch Operations">
    Load multiple entities in parallel to reduce round trips.

    ```typescript
    // Load multiple entities at once
    async function findMany(ids: string[]) {
      return Promise.all(
        ids.map(id => repository.findOne({ entityId: id }))
      );
    }

    // Batch commits
    async function commitBatch(entities: Entity[]) {
      const allEvents = entities.flatMap(e => e.uncommittedEvents);
      await adapter.commitEvents({ events: allEvents });
    }
    ```

    **Benefits:**
    - Reduces database round trips
    - Better throughput for bulk operations
    - Lower latency for multiple reads
  </Accordion>

  <Accordion title="Strategy 4: Database Indexing">
    Create proper indexes for fast event lookups.

    ```sql
    -- Essential indexes
    CREATE INDEX idx_entity ON events (entity_name, entity_id);
    CREATE INDEX idx_time ON events (event_created_at);

    -- Optional: For filtering
    CREATE INDEX idx_event_name ON events (event_name);
    ```

    **Query optimization:**
    ```typescript
    // Use indexed fields in queries
    const events = await db.find({
      entityName: "user",  // indexed
      entityId: "123"      // indexed
    }).sort({ eventCreatedAt: 1 });  // indexed
    ```
  </Accordion>

  <Accordion title="Strategy 5: Event Compaction">
    Periodically compress old events into summary events.

    ```typescript
    // Before: 1000 events
    "user:name_updated" × 500
    "user:email_updated" × 300
    "user:profile_updated" × 200

    // After: 1 compacted event
    {
      eventName: "user:state_compacted",
      body: {
        name: "Final Name",
        email: "final@example.com",
        profile: { /* final state */ }
      }
    }
    ```

    **When to compact:**
    - Entities with >1000 events
    - Mostly inactive entities
    - After major migrations
  </Accordion>
</Accordions>

## Performance Monitoring

Track these metrics to identify bottlenecks:

```typescript
const metrics = {
  eventCount: events.length,
  loadTime: Date.now() - startTime,
  snapshotHit: snapshot !== null,
  cacheHit: cached !== undefined
};

console.log('Performance:', metrics);
```

## Best Practices

- Start with snapshots (easiest, biggest impact)
- Add caching for frequently accessed entities
- Use batch operations for bulk workloads
- Monitor performance metrics
- Optimize hot paths first

## When to Optimize

Don't optimize prematurely. Consider optimization when:
- Entity load times exceed 100ms
- Event counts exceed 1000 per entity
- Database queries become slow
- User experience is impacted
