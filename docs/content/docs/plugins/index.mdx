---
title: Plugins Overview
description: Extend repository behavior with plugins for side effects like analytics, logging, and notifications
---

# Plugins Overview

Plugins are a powerful way to extend Ventyd repositories with side effects like analytics, logging, notifications, and event broadcasting. They execute **after** events are committed, ensuring the main business logic stays fast and reliable.

## What are Plugins?

Plugins are functions that respond to committed events without blocking the core event sourcing flow. They provide a clean way to integrate with external systems while maintaining the integrity of your event log.

### Key Characteristics

- **Non-blocking**: Plugins run after events are safely persisted
- **Parallel Execution**: All plugins execute concurrently using `Promise.allSettled`
- **Isolated Failures**: One plugin failure doesn't affect others or the main commit flow
- **Access to Full State**: Receive entity name, ID, committed events, and final state

## Plugin Interface

All plugins implement the `Plugin` interface:

```typescript
import type { Plugin } from 'ventyd';

interface Plugin {
  async onCommitted({
    entityName: string;
    entityId: string;
    events: Event[];
    state: any;
  }): Promise<void>;
}
```

### Plugin Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `entityName` | `string` | Name of the entity (e.g., "user", "order") |
| `entityId` | `string` | Unique identifier of the entity |
| `events` | `Event[]` | Array of events that were just committed |
| `state` | `any` | Final entity state after applying all events |

## Creating a Basic Plugin

Here's a simple analytics plugin example:

```typescript
const analyticsPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events }) {
    // Process each committed event
    for (const event of events) {
      await analytics.track({
        event: event.eventName,
        entityId,
        entityName,
        properties: event.body,
        timestamp: event.eventCreatedAt
      });
    }
  }
};
```

## Using Plugins

Add plugins when creating a repository:

```typescript
import { createRepository } from 'ventyd';

const userRepository = createRepository(User, {
  adapter,
  plugins: [
    analyticsPlugin,
    auditLoggingPlugin,
    eventBroadcastPlugin,
    searchIndexPlugin
  ]
});
```

## Plugin Execution Model

Understanding how plugins execute is crucial for building reliable systems:

### Execution Order

1. **Event Validation & Commit**: Events are validated and persisted to storage
2. **Parallel Plugin Execution**: All plugins run concurrently
3. **Error Isolation**: Plugin errors are caught and reported
4. **Return to Caller**: `commit()` returns after all plugins complete

### Guarantees

```typescript
// Plugins are GUARANTEED to:
- Run ONLY after events are persisted
- Execute in PARALLEL (not sequential)
- Have ISOLATED errors (one failure doesn't affect others)
- Complete AFTER commit() returns
```

## Error Handling

Handle plugin errors gracefully with the `onPluginError` callback:

```typescript
const userRepository = createRepository(User, {
  adapter,
  plugins: [analyticsPlugin, notificationPlugin],
  onPluginError: (error, plugin) => {
    // Log the error
    logger.error('Plugin execution failed', {
      error: error instanceof Error ? error.message : String(error),
      plugin: plugin.constructor.name
    });

    // Send to error tracking service
    sentry.captureException(error, {
      tags: { component: 'plugin' },
      level: 'warning'
    });
  }
});
```

### Error Handling Strategy

```typescript
// Individual plugins should handle errors gracefully
const resilientPlugin: Plugin = {
  async onCommitted({ events }) {
    try {
      // Try to send notifications
      await notificationService.send(events);
    } catch (error) {
      // Log but don't throw - non-critical operations can fail
      logger.warn('Notification failed', error);
      // Optionally: retry, queue for later, etc.
    }
  }
};
```

## Common Plugin Patterns

### 1. Analytics Plugin

Track business metrics and user behavior:

```typescript
const analyticsPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events }) {
    for (const event of events) {
      await analytics.track({
        name: event.eventName,
        userId: entityId,
        entityType: entityName,
        properties: event.body,
        timestamp: event.eventCreatedAt
      });
    }
  }
};
```

### 2. Audit Logging Plugin

Record all state changes for compliance:

```typescript
const auditPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    await auditLog.record({
      entity: `${entityName}:${entityId}`,
      eventCount: events.length,
      eventNames: events.map(e => e.eventName),
      finalState: state,
      timestamp: new Date().toISOString()
    });
  }
};
```

### 3. Event Broadcasting Plugin

Publish events to message queues:

```typescript
const eventBusPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events }) {
    for (const event of events) {
      await eventBus.publish(event.eventName, {
        entityName,
        entityId,
        body: event.body,
        timestamp: event.eventCreatedAt
      });
    }
  }
};
```

### 4. Search Indexing Plugin

Keep search indexes synchronized:

```typescript
const searchIndexPlugin: Plugin = {
  async onCommitted({ entityName, entityId, state }) {
    await searchEngine.index({
      id: `${entityName}:${entityId}`,
      type: entityName,
      document: state
    });
  }
};
```

## Plugin Best Practices

### 1. Keep Plugins Fast

Plugins block `commit()` completion. For heavy work, enqueue background jobs:

```typescript
// Good - Enqueue for background processing
const heavyPlugin: Plugin = {
  async onCommitted({ events }) {
    // Just queue the job, don't process here
    await jobQueue.enqueue('process-events', events);
  }
};

// Avoid - Heavy processing blocks commit
const slowPlugin: Plugin = {
  async onCommitted({ events }) {
    // This could take minutes!
    await processLargeDataset(events);
  }
};
```

### 2. Make Plugins Idempotent

Use event IDs to prevent duplicate processing:

```typescript
const idempotentPlugin: Plugin = {
  async onCommitted({ events }) {
    for (const event of events) {
      // processOnce() prevents duplicate processing
      await processOnce(event.eventId, () => {
        return analytics.track(event);
      });
    }
  }
};
```

### 3. Handle Errors Gracefully

```typescript
const resilientPlugin: Plugin = {
  async onCommitted({ events }) {
    try {
      await externalService.notify(events);
    } catch (error) {
      // Log but don't throw
      logger.error('Notification failed', error);
      // Optionally queue for retry
      await retryQueue.push({ events, error });
    }
  }
};
```

### 4. Respect Entity Boundaries

Work with provided data, don't load other entities:

```typescript
// Good - Use provided data
const goodPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events }) {
    await logger.info(
      `${entityName}:${entityId} had ${events.length} events`
    );
  }
};

// Avoid - Don't load other entities
const badPlugin: Plugin = {
  async onCommitted({ entityId }) {
    // This breaks entity isolation!
    const user = await userRepo.findOne({ entityId });
  }
};
```

## Advanced Patterns

### Conditional Plugin Execution

Only run plugin logic for certain events:

```typescript
const importantEventsPlugin: Plugin = {
  async onCommitted({ events, entityName, entityId, state }) {
    const importantEvents = events.filter(e =>
      e.eventName.includes('created') ||
      e.eventName.includes('deleted')
    );

    if (importantEvents.length > 0) {
      await notificationService.send({
        title: `Important ${entityName} event`,
        events: importantEvents,
        entityId,
        state
      });
    }
  }
};
```

### State-Based Plugin Logic

React to state changes, not just events:

```typescript
const statusChangePlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    const statusChanges = events.filter(e =>
      e.eventName.includes('status')
    );

    if (statusChanges.length > 0 && state.status === 'completed') {
      await webhook.send({
        entityName,
        entityId,
        newStatus: state.status,
        completedAt: new Date().toISOString()
      });
    }
  }
};
```

### Aggregating Multiple Events

Process events as a batch:

```typescript
const batchPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events }) {
    if (events.length > 1) {
      // Multiple events in one commit - batch process
      await analytics.batchTrack(
        events.map(e => ({
          name: e.eventName,
          properties: e.body
        }))
      );
    } else if (events.length === 1) {
      // Single event
      const event = events[0];
      await analytics.track(event.eventName, event.body);
    }
  }
};
```

## Next Steps

Learn how to implement specific plugin types:

- [Analytics Plugin](/docs/plugins/analytics)
- [Audit Logging Plugin](/docs/plugins/audit-logging)
- [Event Broadcasting Plugin](/docs/plugins/event-broadcasting)
- [Search Indexing Plugin](/docs/plugins/search-indexing)
- [Creating Custom Plugins](/docs/plugins/creating-plugins)

Or explore [Best Practices](/docs/best-practices) for building robust event-sourced systems.
