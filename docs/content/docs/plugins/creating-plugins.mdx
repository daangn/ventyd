---
title: Creating Custom Plugins
description: Build custom plugins to extend Ventyd with your own side effects and integrations
---

# Creating Custom Plugins

Custom plugins let you extend Ventyd with your own side effects, integrations, and business logic. This guide shows you how to create robust, production-ready plugins.

## Plugin Basics

Every plugin implements the `Plugin` interface:

```typescript
import type { Plugin } from 'ventyd';

interface Plugin {
  async onCommitted({
    entityName: string;
    entityId: string;
    events: Event[];
    state: any;
  }): Promise<void>;
}
```

### Creating Your First Plugin

```typescript
const helloWorldPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events }) {
    console.log(
      `Committed ${events.length} events to ${entityName}:${entityId}`
    );
  }
};
```

### Using Your Plugin

```typescript
import { createRepository } from 'ventyd';

const repository = createRepository(MyEntity, {
  adapter,
  plugins: [helloWorldPlugin]
});
```

## Plugin Patterns

### Pattern 1: External Service Integration

Integrate with external APIs or services:

```typescript
const externalServicePlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    // Send data to external service
    const response = await fetch('https://api.example.com/sync', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        entityName,
        entityId,
        events,
        state
      })
    });

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`);
    }
  }
};
```

### Pattern 2: Data Transformation and Storage

Transform and store data in a different system:

```typescript
const dataWarehousePlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    // Transform Ventyd events into data warehouse format
    const warehouseRecords = events.map(event => ({
      record_id: `${entityId}_${event.eventId}`,
      entity_type: entityName,
      entity_id: entityId,
      event_name: event.eventName,
      event_properties: event.body,
      entity_state: state,
      event_timestamp: event.eventCreatedAt,
      processed_at: new Date().toISOString()
    }));

    // Batch insert to data warehouse
    await dataWarehouse.batchInsert(
      `${entityName}_events`,
      warehouseRecords
    );
  }
};
```

### Pattern 3: Derived State Synchronization

Keep a read model in sync with event-sourced state:

```typescript
const readModelSyncPlugin: Plugin = {
  async onCommitted({ entityName, entityId, state }) {
    // Update read model with latest state
    const readModel = {
      id: entityId,
      type: entityName,
      ...state,
      updatedAt: new Date().toISOString()
    };

    // Upsert in read model database
    await readModelDB.upsert(
      { type: entityName, id: entityId },
      readModel
    );
  }
};
```

### Pattern 4: Business Rule Enforcement

Validate state and trigger side effects based on business rules:

```typescript
const businessRulePlugin: Plugin = {
  async onCommitted({ entityName, entityId, state, events }) {
    // Check if state violates any business rules
    if (entityName === 'subscription' && state.status === 'cancelled') {
      // Refund pending charges
      await refundService.processPendingRefunds({
        subscriptionId: entityId,
        amount: state.balance
      });

      // Notify customer
      await emailService.send({
        to: state.customerEmail,
        template: 'subscription_cancelled',
        data: { subscriptionId: entityId }
      });
    }
  }
};
```

### Pattern 5: Multi-Tenant Isolation

Handle multi-tenant scenarios:

```typescript
interface TenantContext {
  tenantId: string;
}

const multiTenantPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    // Get tenant from entity context
    const tenantId = extractTenantId(state);

    // Ensure operations are scoped to tenant
    await tenantDB.withTenant(tenantId, async (tenantDb) => {
      for (const event of events) {
        await tenantDb.collection('events').insertOne({
          entityName,
          entityId,
          eventName: event.eventName,
          body: event.body,
          timestamp: event.eventCreatedAt
        });
      }
    });
  }
};

function extractTenantId(state: any): string {
  // Could come from entity state, context, or environment
  return state.tenantId || process.env.TENANT_ID || 'default';
}
```

## Advanced Patterns

### Pattern 6: Event Aggregation

Aggregate multiple events before processing:

```typescript
interface AggregatedEvent {
  entityName: string;
  entityId: string;
  eventCount: number;
  eventNames: string[];
  timeRange: {
    from: string;
    to: string;
  };
  state: any;
}

const eventAggregatorPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    const aggregated: AggregatedEvent = {
      entityName,
      entityId,
      eventCount: events.length,
      eventNames: events.map(e => e.eventName),
      timeRange: {
        from: events[0].eventCreatedAt,
        to: events[events.length - 1].eventCreatedAt
      },
      state
    };

    // Process aggregated data
    await analytics.trackAggregatedEvent(aggregated);
  }
};
```

### Pattern 7: Conditional Logic Based on Events

Trigger different logic based on specific events:

```typescript
const conditionalPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    for (const event of events) {
      switch (true) {
        case event.eventName === 'user:created':
          // Send welcome email
          await emailService.sendWelcome({
            email: state.email,
            name: state.name
          });
          break;

        case event.eventName.includes('status') &&
          state.status === 'completed':
          // Archive old records
          await archive.moveToLongTerm({
            entityId,
            entityName
          });
          break;

        case event.eventName === 'user:subscription_cancelled':
          // Clean up resources
          await cleanup.removeUserResources({
            userId: entityId
          });
          break;
      }
    }
  }
};
```

### Pattern 8: Retry Logic with Exponential Backoff

Handle transient failures gracefully:

```typescript
interface RetryableOperation {
  attempt: number;
  maxRetries: number;
  delay: number;
  operation: () => Promise<void>;
}

const retryablePlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    for (const event of events) {
      await retryWithBackoff(
        {
          attempt: 0,
          maxRetries: 3,
          delay: 1000,
          operation: () =>
            externalService.send({
              entityName,
              entityId,
              event
            })
        }
      );
    }
  }
};

async function retryWithBackoff(config: RetryableOperation) {
  try {
    await config.operation();
  } catch (error) {
    if (config.attempt < config.maxRetries) {
      // Wait before retrying
      await delay(config.delay * Math.pow(2, config.attempt));

      // Retry with exponential backoff
      return retryWithBackoff({
        ...config,
        attempt: config.attempt + 1,
        delay: config.delay * 2
      });
    }

    // Max retries exceeded
    throw error;
  }
}

function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

## Real-World Examples

### Notification Service Plugin

Send notifications through multiple channels:

```typescript
const notificationPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    for (const event of events) {
      const notification = buildNotification(event, state);

      if (notification) {
        // Send through all configured channels
        await Promise.allSettled([
          notificationService.sendEmail(notification),
          notificationService.sendSMS(notification),
          notificationService.sendInApp(notification),
          notificationService.sendSlack(notification)
        ]);
      }
    }
  }
};

function buildNotification(event: any, state: any) {
  switch (event.eventName) {
    case 'order:shipped':
      return {
        title: 'Your order has shipped!',
        body: `Order ${state.id} is on its way. Tracking: ${event.body.trackingNumber}`,
        channels: ['email', 'sms', 'inApp'],
        recipient: state.customerEmail
      };

    case 'user:subscription_expiring':
      return {
        title: 'Subscription expiring soon',
        body: 'Renew now to avoid service interruption',
        channels: ['email', 'inApp'],
        recipient: state.email,
        action: { url: '/renew-subscription' }
      };

    default:
      return null;
  }
}
```

### Compliance and Audit Plugin

Track changes for compliance requirements:

```typescript
const compliancePlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    const complianceEvents = events.filter(e => {
      const sensitivePatterns = ['payment', 'deleted', 'disabled', 'access'];
      return sensitivePatterns.some(p =>
        e.eventName.includes(p)
      );
    });

    if (complianceEvents.length > 0) {
      // Log for audit
      await auditLog.record({
        entityType: entityName,
        entityId,
        complianceLevel: 'STRICT',
        events: complianceEvents,
        timestamp: new Date().toISOString(),
        archived: true
      });

      // Notify compliance team if critical
      const critical = complianceEvents.filter(e =>
        ['deleted', 'disabled'].some(p => e.eventName.includes(p))
      );

      if (critical.length > 0) {
        await notifyComplianceTeam({
          entityType: entityName,
          entityId,
          criticalEvents: critical
        });
      }
    }
  }
};
```

### Cache Invalidation Plugin

Keep caches in sync with state changes:

```typescript
const cacheInvalidationPlugin: Plugin = {
  async onCommitted({ entityName, entityId, state, events }) {
    // Invalidate entity cache
    await cache.delete(`${entityName}:${entityId}`);

    // Invalidate related caches based on events
    for (const event of events) {
      const invalidations = getRelatedCaches(event, state);

      for (const cacheKey of invalidations) {
        await cache.delete(cacheKey);
      }
    }

    // Optionally warm cache with new data
    await cache.set(`${entityName}:${entityId}`, state, {
      ttl: 3600 // 1 hour
    });
  }
};

function getRelatedCaches(event: any, state: any): string[] {
  const caches = [];

  if (event.eventName.includes('user')) {
    caches.push(`user-list`, `user-count`);
  }

  if (event.eventName.includes('status')) {
    caches.push(`${state.category}-list`, `${state.status}-count`);
  }

  return caches;
}
```

## Best Practices

### Do's

```typescript
// Do: Handle errors gracefully without blocking
const robustPlugin: Plugin = {
  async onCommitted({ events }) {
    for (const event of events) {
      try {
        await externalService.send(event);
      } catch (error) {
        // Log but don't throw
        logger.error('Event processing failed', { error, event });
        // Queue for retry if needed
        await retryQueue.enqueue({ event, error });
      }
    }
  }
};

// Do: Make operations idempotent
const idempotentPlugin: Plugin = {
  async onCommitted({ events }) {
    for (const event of events) {
      // Use event ID to prevent duplicate processing
      const processed = await db.findOne({
        processedEventId: event.eventId
      });

      if (!processed) {
        await externalService.send(event);
        await db.insertOne({
          processedEventId: event.eventId,
          processedAt: new Date()
        });
      }
    }
  }
};

// Do: Keep plugins focused and single-purpose
const focusedPlugin: Plugin = {
  async onCommitted({ events }) {
    // This plugin only handles notifications
    for (const event of events) {
      const notification = buildNotification(event);
      if (notification) {
        await notificationService.send(notification);
      }
    }
  }
};

// Do: Log important operations
const loggingPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events }) {
    logger.info('Processing committed events', {
      entityName,
      entityId,
      eventCount: events.length,
      eventNames: events.map(e => e.eventName)
    });

    for (const event of events) {
      logger.debug('Processing event', {
        eventName: event.eventName,
        eventId: event.eventId
      });
    }
  }
};
```

### Don'ts

```typescript
// Don't: Block on slow operations
// BAD
const slowPlugin: Plugin = {
  async onCommitted({ events }) {
    for (const event of events) {
      // This could take minutes!
      await heavyProcessing(event);
    }
  }
};

// GOOD: Queue heavy work
const asyncPlugin: Plugin = {
  async onCommitted({ events }) {
    // Just queue the work
    await jobQueue.enqueue('process-events', events);
  }
};

// Don't: Mutate plugin state unsafely
// BAD
let cache: any = {};
const unsafePlugin: Plugin = {
  async onCommitted({ events }) {
    // Race conditions possible!
    for (const event of events) {
      cache[event.eventId] = event;
    }
  }
};

// GOOD: Use thread-safe storage
const safePlugin: Plugin = {
  async onCommitted({ events }) {
    // Use database for shared state
    await db.bulkInsert(events);
  }
};

// Don't: Throw errors and block commits
// BAD
const blockingPlugin: Plugin = {
  async onCommitted({ events }) {
    for (const event of events) {
      // Throwing here blocks commit!
      await unreliableService.send(event);
    }
  }
};

// GOOD: Handle errors gracefully
const nonBlockingPlugin: Plugin = {
  async onCommitted({ events }) {
    for (const event of events) {
      try {
        await service.send(event);
      } catch (error) {
        logger.error('Send failed', error);
        // Don't re-throw
      }
    }
  }
};

// Don't: Load additional entities
// BAD
const badPlugin: Plugin = {
  async onCommitted({ entityId }) {
    // Breaking entity isolation!
    const user = await userRepo.findOne({ entityId });
    const orders = await orderRepo.findByUserId(entityId);
  }
};

// GOOD: Only use provided data
const goodPlugin: Plugin = {
  async onCommitted({ entityName, entityId, state }) {
    // Only work with provided data
    await service.process({ entityName, entityId, state });
  }
};
```

## Testing Your Plugin

Write comprehensive tests:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';

describe('Custom Plugin', () => {
  let mockService: any;

  beforeEach(() => {
    mockService = {
      send: vi.fn().mockResolvedValue(undefined)
    };
  });

  it('sends events to external service', async () => {
    const plugin: Plugin = {
      async onCommitted({ events }) {
        for (const event of events) {
          await mockService.send(event);
        }
      }
    };

    const events = [
      {
        eventName: 'user:created',
        eventId: '1',
        body: { email: 'test@example.com' },
        eventCreatedAt: '2024-01-01T00:00:00Z'
      }
    ];

    await plugin.onCommitted({
      entityName: 'user',
      entityId: 'user-123',
      events,
      state: { email: 'test@example.com' }
    });

    expect(mockService.send).toHaveBeenCalledWith(events[0]);
  });

  it('handles errors gracefully', async () => {
    mockService.send.mockRejectedValueOnce(
      new Error('Service unavailable')
    );

    const loggerMock = { error: vi.fn() };

    const plugin: Plugin = {
      async onCommitted({ events }) {
        try {
          await mockService.send(events[0]);
        } catch (error) {
          loggerMock.error('Failed', error);
        }
      }
    };

    // Should not throw
    await plugin.onCommitted({
      entityName: 'user',
      entityId: 'user-123',
      events: [{ eventName: 'user:created' }] as any,
      state: {}
    });

    expect(loggerMock.error).toHaveBeenCalled();
  });

  it('makes operations idempotent', async () => {
    const processedEvents = new Set<string>();

    const plugin: Plugin = {
      async onCommitted({ events }) {
        for (const event of events) {
          if (!processedEvents.has(event.eventId)) {
            await mockService.send(event);
            processedEvents.add(event.eventId);
          }
        }
      }
    };

    const event = {
      eventId: '1',
      eventName: 'user:created',
      body: {}
    } as any;

    // Process same event twice
    await plugin.onCommitted({
      entityName: 'user',
      entityId: 'user-123',
      events: [event],
      state: {}
    });

    await plugin.onCommitted({
      entityName: 'user',
      entityId: 'user-123',
      events: [event],
      state: {}
    });

    // Should only be processed once
    expect(mockService.send).toHaveBeenCalledTimes(1);
  });
});
```

## Plugin Development Checklist

- [ ] Implement the `Plugin` interface
- [ ] Add type safety with TypeScript
- [ ] Handle errors without throwing
- [ ] Make operations idempotent
- [ ] Log important operations
- [ ] Avoid blocking operations
- [ ] Write unit tests
- [ ] Document your plugin
- [ ] Add configuration options
- [ ] Consider performance implications

## Related Documentation

- [Plugins Overview](/docs/plugins)
- [Analytics Plugin](/docs/plugins/analytics)
- [Audit Logging Plugin](/docs/plugins/audit-logging)
- [Event Broadcasting Plugin](/docs/plugins/event-broadcasting)
- [Search Indexing Plugin](/docs/plugins/search-indexing)
