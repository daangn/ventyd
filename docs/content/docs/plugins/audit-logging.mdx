---
title: Audit Logging Plugin
description: Record all state changes for compliance and regulatory requirements
---

# Audit Logging Plugin

The Audit Logging Plugin maintains a complete audit trail of all entity changes, essential for compliance, regulatory requirements, and security investigations.

## Overview

Audit logging captures:

- Complete history of all state changes
- Who made the change (via entity context)
- What changed (events and state)
- When changes occurred (timestamps)
- Why changes happened (event details)

This creates an immutable record for:

- Regulatory compliance (GDPR, HIPAA, SOX, etc.)
- Fraud detection and investigation
- Security auditing
- Operational debugging
- Historical analysis

## Basic Implementation

### Simple Audit Logger

```typescript
import type { Plugin } from 'ventyd';

const auditLoggingPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    await auditLog.record({
      entity: `${entityName}:${entityId}`,
      eventCount: events.length,
      eventNames: events.map(e => e.eventName),
      finalState: state,
      timestamp: new Date().toISOString()
    });
  }
};
```

### Using with Repository

```typescript
import { createRepository } from 'ventyd';

const userRepository = createRepository(User, {
  adapter,
  plugins: [auditLoggingPlugin]
});

// All changes are automatically logged
const user = User.create({ body: { email: 'john@example.com' } });
user.updateProfile({ bio: 'Software Engineer' });
await userRepository.commit(user);
// Audit trail recorded with both events and final state
```

## Advanced Implementation

### Detailed Audit Logging

Log comprehensive information about each change:

```typescript
const detailedAuditLoggingPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    for (const event of events) {
      await auditLog.record({
        // Entity identification
        entityType: entityName,
        entityId,
        entityState: state,

        // Event details
        eventId: event.eventId,
        eventName: event.eventName,
        eventBody: event.body,
        eventCreatedAt: event.eventCreatedAt,

        // Audit metadata
        recordedAt: new Date().toISOString(),
        source: 'ventyd-event-sourcing',
        version: '1.0'
      });
    }
  }
};
```

### User-Attributed Audit Logging

Track which user made each change:

```typescript
interface AuditContext {
  userId?: string;
  username?: string;
  ipAddress?: string;
  userAgent?: string;
}

const auditContextMap = new Map<string, AuditContext>();

const userAttributedAuditPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    // Get the context for this commit
    const context = auditContextMap.get(entityId) || {};

    for (const event of events) {
      await auditLog.record({
        entity: `${entityName}:${entityId}`,

        // Event information
        eventName: event.eventName,
        eventId: event.eventId,
        eventBody: event.body,
        eventTimestamp: event.eventCreatedAt,

        // User information
        userId: context.userId,
        username: context.username,
        ipAddress: context.ipAddress,
        userAgent: context.userAgent,

        // State change
        newState: state,

        // Audit metadata
        auditedAt: new Date().toISOString(),
        action: 'MODIFY'
      });
    }
  }
};

// When committing, set the context
export async function commitWithAudit(
  entity: any,
  userId: string,
  ipAddress: string,
  userAgent: string
) {
  auditContextMap.set(entity.entityId, {
    userId,
    ipAddress,
    userAgent
  });

  try {
    await repository.commit(entity);
  } finally {
    auditContextMap.delete(entity.entityId);
  }
}
```

### Event-Based Audit Actions

Map events to audit actions for better classification:

```typescript
const actionAuditPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    for (const event of events) {
      const action = mapEventToAction(event.eventName);

      await auditLog.record({
        entityType: entityName,
        entityId,
        action,
        severity: calculateSeverity(action),
        eventName: event.eventName,
        eventBody: event.body,
        newState: state,
        timestamp: event.eventCreatedAt,
        recordedAt: new Date().toISOString()
      });
    }
  }
};

function mapEventToAction(eventName: string): string {
  if (eventName.includes('created')) return 'CREATE';
  if (eventName.includes('deleted')) return 'DELETE';
  if (eventName.includes('updated')) return 'UPDATE';
  if (eventName.includes('activated')) return 'ACTIVATE';
  if (eventName.includes('deactivated')) return 'DEACTIVATE';
  return 'MODIFY';
}

function calculateSeverity(action: string): 'HIGH' | 'MEDIUM' | 'LOW' {
  if (action === 'DELETE') return 'HIGH';
  if (action === 'CREATE') return 'MEDIUM';
  return 'LOW';
}
```

## Real-World Examples

### Banking System Audit Trail

Track all financial transactions and account changes:

```typescript
const bankingAuditPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    if (entityName !== 'bankAccount') return;

    for (const event of events) {
      await auditLog.record({
        // Account identification
        accountId: entityId,
        accountNumber: state.accountNumber,
        accountHolder: state.accountHolder,

        // Transaction details
        transactionType: event.eventName,
        amount: event.body.amount,
        balanceAfter: state.balance,

        // Regulatory information
        timestamp: event.eventCreatedAt,
        auditTrail: {
          operationId: event.eventId,
          operationType: mapEventToOperation(event.eventName),
          balanceDifference: calculateBalanceDifference(
            event,
            state
          )
        },

        // Required for compliance
        complianceLevel: 'STRICT',
        archived: false,
        deletionAllowed: false
      });
    }
  }
};
```

### Healthcare System Audit Trail

Track patient record changes with HIPAA compliance:

```typescript
const hipaaAuditPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    if (entityName !== 'patientRecord') return;

    for (const event of events) {
      await auditLog.record({
        // Patient identification (de-identified for privacy)
        patientId: entityId,
        mrn: state.medicalRecordNumber,

        // Access information
        accessTimestamp: new Date().toISOString(),
        accessType: 'WRITE',

        // Change details
        changeType: event.eventName,
        fieldsChanged: Object.keys(event.body),
        oldValues: await getPreviousValues(entityId, event),
        newValues: event.body,

        // HIPAA compliance
        hipaaRelevant: true,
        minRetentionYears: 6,
        retentionUntil: addYears(new Date(), 6),

        // User information (encrypted)
        userId: await encryptUserId(event.userId),
        actionReason: event.actionReason
      });
    }
  }
};
```

### E-Commerce Order Audit Trail

Track all order and payment changes:

```typescript
const ecommerceAuditPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    if (entityName !== 'order') return;

    for (const event of events) {
      // Determine if this is sensitive
      const isSensitive = [
        'order:payment_received',
        'order:refund_issued',
        'order:address_changed'
      ].includes(event.eventName);

      await auditLog.record({
        orderId: entityId,
        customerId: state.customerId,

        // Event details
        eventName: event.eventName,
        eventBody: isSensitive ? redactSensitiveData(event.body) : event.body,

        // Financial impact
        financialImpact: extractFinancialImpact(event),
        orderTotal: state.total,
        status: state.status,

        // Audit metadata
        severity: isSensitive ? 'HIGH' : 'NORMAL',
        timestamp: event.eventCreatedAt,
        auditedAt: new Date().toISOString(),
        requiresReview: isSensitive
      });
    }
  }
};

function redactSensitiveData(body: any) {
  return {
    ...body,
    creditCard: '****-****-****-' + body.creditCard?.slice(-4),
    cvv: undefined
  };
}
```

## Integration Examples

### PostgreSQL Audit Table

```typescript
import { Pool } from 'pg';

const pool = new Pool(process.env.DATABASE_URL);

const postgresAuditPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    const query = `
      INSERT INTO audit_log (
        entity_type, entity_id, event_name, event_body,
        final_state, event_timestamp, recorded_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7)
    `;

    for (const event of events) {
      await pool.query(query, [
        entityName,
        entityId,
        event.eventName,
        JSON.stringify(event.body),
        JSON.stringify(state),
        event.eventCreatedAt,
        new Date().toISOString()
      ]);
    }
  }
};
```

### MongoDB Audit Collection

```typescript
import { MongoClient } from 'mongodb';

const mongoAuditPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    const client = new MongoClient(process.env.MONGODB_URI);
    const db = client.db(process.env.MONGODB_DB);
    const auditCollection = db.collection('audit_logs');

    await auditCollection.insertMany(
      events.map(event => ({
        entityType: entityName,
        entityId,
        eventName: event.eventName,
        eventBody: event.body,
        finalState: state,
        eventTimestamp: new Date(event.eventCreatedAt),
        recordedAt: new Date(),
        _createdAt: new Date() // For TTL index
      }))
    );
  }
};
```

### Elasticsearch Audit Indexing

```typescript
import { Client } from '@elastic/elasticsearch';

const elasticsearchAuditPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    const client = new Client({ node: process.env.ELASTICSEARCH_URL });

    const documents = events.map(event => ({
      entityType: entityName,
      entityId,
      eventName: event.eventName,
      eventBody: event.body,
      finalState: state,
      timestamp: event.eventCreatedAt,
      @timestamp: new Date().toISOString()
    }));

    for (const doc of documents) {
      await client.index({
        index: 'audit-logs',
        body: doc
      });
    }
  }
};
```

## Best Practices

### Do's

```typescript
// Do: Record all changes
const comprehensivePlugin: Plugin = {
  async onCommitted({ events, state }) {
    for (const event of events) {
      // Log every single change
      await auditLog.record(event);
    }
  }
};

// Do: Include timestamps
const timestampedPlugin: Plugin = {
  async onCommitted({ events }) {
    for (const event of events) {
      await auditLog.record({
        eventTimestamp: event.eventCreatedAt,
        recordedAt: new Date().toISOString()
      });
    }
  }
};

// Do: Make audit logs immutable
// Use write-once storage (append-only logs)
const immutablePlugin: Plugin = {
  async onCommitted({ events, state }) {
    // Use append-only storage
    await appendOnlyLog.append({
      events,
      state,
      sealed: true // Can't be modified
    });
  }
};

// Do: Redact sensitive data
const redactedPlugin: Plugin = {
  async onCommitted({ events, state }) {
    for (const event of events) {
      const redacted = {
        ...event,
        body: redactPII(event.body)
      };
      await auditLog.record(redacted);
    }
  }
};
```

### Don'ts

```typescript
// Don't: Store sensitive data unencrypted
// BAD
const badPlugin: Plugin = {
  async onCommitted({ events }) {
    // Storing passwords in plain text!
    await auditLog.record(events);
  }
};

// GOOD: Encrypt before storing
const goodPlugin: Plugin = {
  async onCommitted({ events }) {
    const encrypted = await Promise.all(
      events.map(e => encryptEvent(e))
    );
    await auditLog.record(encrypted);
  }
};

// Don't: Allow deletion of audit logs
// BAD: Audit logs should never be deletable
const mutablePlugin: Plugin = {
  async onCommitted({ events }) {
    // Store in deletable collection
    await collection.insertMany(events);
  }
};

// GOOD: Use append-only storage
const immutablePlugin: Plugin = {
  async onCommitted({ events }) {
    // Append only, never delete
    await appendOnlyLog.append(events);
  }
};

// Don't: Lose context
const poorContextPlugin: Plugin = {
  async onCommitted({ events }) {
    // Just storing events without context
    // BAD: Missing who, where, why
    events.forEach(e => auditLog.record(e));
  }
};

// GOOD: Include full context
const richContextPlugin: Plugin = {
  async onCommitted({
    entityName,
    entityId,
    events,
    state
  }) {
    for (const event of events) {
      auditLog.record({
        entityType: entityName,
        entityId,
        ...event,
        state,
        timestamp: event.eventCreatedAt
      });
    }
  }
};
```

## Compliance Considerations

### GDPR Compliance

```typescript
const gdprAuditPlugin: Plugin = {
  async onCommitted({ events, state }) {
    for (const event of events) {
      await auditLog.record({
        event,
        state,

        // GDPR requirements
        hasPersonalData: checkForPersonalData(event.body),
        processingBasis: 'contract', // or 'consent', 'legal', etc.
        dataProcessor: 'internal',

        // Right to be forgotten
        pseudonymized: true,
        canBePermanentlyDeleted: false,

        // Audit trail requirement
        timestamp: event.eventCreatedAt,
        auditedAt: new Date().toISOString()
      });
    }
  }
};
```

### Data Retention

```typescript
const retentionAuditPlugin: Plugin = {
  async onCommitted({ entityName, events, state }) {
    const retentionPolicy = getRetentionPolicy(entityName);

    for (const event of events) {
      const deleteAt = addDays(
        new Date(),
        retentionPolicy.retentionDays
      );

      await auditLog.record({
        event,
        state,

        // Retention policy
        retentionDays: retentionPolicy.retentionDays,
        deleteAt,
        retentionCategory: retentionPolicy.category,

        timestamp: event.eventCreatedAt
      });
    }
  }
};
```

## Testing

Test audit logging with comprehensive tests:

```typescript
import { describe, it, expect, vi } from 'vitest';

describe('Audit Logging Plugin', () => {
  it('logs all committed events', async () => {
    const recordMock = vi.fn();
    const mockAuditLog = { record: recordMock };

    const events = [
      {
        eventName: 'user:created',
        eventId: '1',
        body: { email: 'test@example.com' },
        eventCreatedAt: '2024-01-01T00:00:00Z'
      }
    ];

    await auditLoggingPlugin.onCommitted({
      entityName: 'user',
      entityId: 'user-123',
      events,
      state: { email: 'test@example.com' }
    });

    expect(recordMock).toHaveBeenCalled();
    const callArgs = recordMock.mock.calls[0][0];
    expect(callArgs.eventName).toBe('user:created');
    expect(callArgs.entityId).toBe('user-123');
  });
});
```

## Related Documentation

- [Plugins Overview](/docs/plugins)
- [Analytics Plugin](/docs/plugins/analytics)
- [Best Practices](/docs/best-practices)
