---
title: Event Broadcasting Plugin
description: Publish events to message queues and external systems
---

# Event Broadcasting Plugin

The Event Broadcasting Plugin publishes committed events to message queues, webhooks, and external systems, enabling event-driven architectures and system integration.

## Overview

Event broadcasting enables:

- Integration with message queues (Kafka, RabbitMQ, AWS SNS/SQS)
- Real-time webhook notifications to external systems
- Fan-out patterns to multiple subscribers
- Event-driven microservices communication
- External system synchronization

## Basic Implementation

### Simple Event Publisher

```typescript
import type { Plugin } from 'ventyd';

const eventBroadcastPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events }) {
    for (const event of events) {
      await eventBus.publish(event.eventName, {
        entityName,
        entityId,
        body: event.body,
        timestamp: event.eventCreatedAt
      });
    }
  }
};
```

### Using with Repository

```typescript
import { createRepository } from 'ventyd';

const userRepository = createRepository(User, {
  adapter,
  plugins: [eventBroadcastPlugin]
});

// Events are automatically published
const user = User.create({ body: { email: 'john@example.com' } });
user.updateProfile({ bio: 'Software Engineer' });
await userRepository.commit(user);
// Published: user:created, user:profile_updated
```

## Advanced Implementation

### Topic-Based Broadcasting

Route events to different topics based on type:

```typescript
const topicBroadcastPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    for (const event of events) {
      const topic = getTopicForEvent(event.eventName);

      await eventBus.publish(topic, {
        entityName,
        entityId,
        eventName: event.eventName,
        eventId: event.eventId,
        body: event.body,
        timestamp: event.eventCreatedAt,
        state: state
      });
    }
  }
};

function getTopicForEvent(eventName: string): string {
  if (eventName.includes('created')) return 'entity.created';
  if (eventName.includes('deleted')) return 'entity.deleted';
  if (eventName.includes('status')) return 'entity.status-changed';
  return 'entity.updated';
}
```

### Conditional Broadcasting

Only broadcast certain events to external systems:

```typescript
const selectiveBroadcastPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    // Filter events to broadcast
    const externalEvents = events.filter(event => {
      const skipPatterns = ['internal', 'temporary'];
      return !skipPatterns.some(pattern =>
        event.eventName.includes(pattern)
      );
    });

    for (const event of externalEvents) {
      await eventBus.publish(event.eventName, {
        entityName,
        entityId,
        body: event.body,
        timestamp: event.eventCreatedAt
      });
    }
  }
};
```

### Enriched Event Broadcasting

Include additional context from state:

```typescript
const enrichedBroadcastPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    for (const event of events) {
      const enrichedEvent = {
        // Event metadata
        entityName,
        entityId,
        eventName: event.eventName,
        eventId: event.eventId,

        // Event payload
        data: event.body,

        // State context
        entityState: state,

        // Routing information
        topic: getTopic(event.eventName),
        priority: getPriority(event.eventName),

        // Timestamps
        occurredAt: event.eventCreatedAt,
        publishedAt: new Date().toISOString(),

        // Metadata for tracing
        traceId: generateTraceId(),
        source: 'ventyd'
      };

      await eventBus.publish(enrichedEvent.topic, enrichedEvent);
    }
  }
};

function getTopic(eventName: string): string {
  const [entityType] = eventName.split(':');
  return entityType;
}

function getPriority(eventName: string): 'high' | 'normal' | 'low' {
  if (eventName.includes('payment')) return 'high';
  if (eventName.includes('deleted')) return 'high';
  return 'normal';
}

function generateTraceId(): string {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
```

## Real-World Examples

### E-Commerce Integration

Broadcast order events to shipping, warehouse, and analytics systems:

```typescript
const ecommerceEventPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    if (entityName !== 'order') return;

    for (const event of events) {
      switch (event.eventName) {
        case 'order:created':
          // Notify warehouse to pick items
          await eventBus.publish('warehouse.order-received', {
            orderId: entityId,
            items: event.body.items,
            shippingAddress: state.shippingAddress
          });

          // Notify payment system
          await eventBus.publish('payment.charge-required', {
            orderId: entityId,
            amount: state.total,
            customerId: state.customerId
          });
          break;

        case 'order:payment_confirmed':
          // Notify warehouse to start packing
          await eventBus.publish('warehouse.start-packing', {
            orderId: entityId
          });

          // Notify customer service
          await eventBus.publish('customer-service.order-paid', {
            orderId: entityId,
            customerId: state.customerId,
            email: state.customerEmail
          });
          break;

        case 'order:shipped':
          // Notify customer
          await eventBus.publish('notification.shipment-notice', {
            orderId: entityId,
            customerId: state.customerId,
            trackingNumber: event.body.trackingNumber,
            email: state.customerEmail
          });

          // Notify third-party tracking integration
          await eventBus.publish('external.shipment-update', {
            orderId: entityId,
            trackingNumber: event.body.trackingNumber
          });
          break;

        case 'order:delivered':
          // Request customer review
          await eventBus.publish('notification.request-review', {
            orderId: entityId,
            customerId: state.customerId,
            items: state.items
          });
          break;
      }
    }
  }
};
```

### Microservices Communication

Coordinate between multiple microservices:

```typescript
const microservicesEventPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    if (entityName !== 'subscription') return;

    for (const event of events) {
      switch (event.eventName) {
        case 'subscription:created':
          // Notify billing microservice
          await eventBus.publish('billing.subscription-started', {
            subscriptionId: entityId,
            customerId: state.customerId,
            plan: event.body.plan,
            billingCycle: event.body.billingCycle,
            amount: event.body.amount
          });

          // Notify feature access microservice
          await eventBus.publish('features.enable-features', {
            customerId: state.customerId,
            plan: event.body.plan
          });
          break;

        case 'subscription:upgraded':
          // Update billing
          await eventBus.publish('billing.subscription-upgraded', {
            subscriptionId: entityId,
            oldPlan: state.previousPlan,
            newPlan: event.body.newPlan
          });

          // Grant new features
          await eventBus.publish('features.upgrade-features', {
            customerId: state.customerId,
            newPlan: event.body.newPlan
          });
          break;

        case 'subscription:cancelled':
          // Stop billing
          await eventBus.publish('billing.subscription-cancelled', {
            subscriptionId: entityId,
            cancellationReason: event.body.reason
          });

          // Disable features
          await eventBus.publish('features.disable-features', {
            customerId: state.customerId
          });
          break;
      }
    }
  }
};
```

### Webhook Broadcasting

Send webhooks to customer endpoints:

```typescript
const webhookBroadcastPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events, state }) {
    // Get registered webhooks for this entity type
    const webhooks = await webhookRegistry.getWebhooks(entityName);

    for (const event of events) {
      for (const webhook of webhooks) {
        // Queue webhook delivery
        await webhookQueue.enqueue({
          webhook,
          event: {
            id: event.eventId,
            type: event.eventName,
            data: event.body,
            timestamp: event.eventCreatedAt,
            entity: {
              type: entityName,
              id: entityId
            }
          },
          retries: 0,
          nextRetry: new Date()
        });
      }
    }
  }
};
```

## Integration Examples

### Kafka Integration

```typescript
import { Kafka } from 'kafkajs';

const kafkaEventPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events }) {
    const kafka = new Kafka({
      clientId: 'ventyd-app',
      brokers: (process.env.KAFKA_BROKERS || '').split(',')
    });

    const producer = kafka.producer();
    await producer.connect();

    for (const event of events) {
      await producer.send({
        topic: `${entityName}.events`,
        messages: [
          {
            key: entityId,
            value: JSON.stringify({
              entityName,
              entityId,
              eventName: event.eventName,
              body: event.body,
              timestamp: event.eventCreatedAt
            })
          }
        ]
      });
    }

    await producer.disconnect();
  }
};
```

### RabbitMQ Integration

```typescript
import amqp from 'amqplib';

const rabbitMQEventPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events }) {
    const connection = await amqp.connect(
      process.env.RABBITMQ_URL || 'amqp://localhost'
    );
    const channel = await connection.createChannel();

    for (const event of events) {
      const exchange = `${entityName}.events`;
      const routingKey = event.eventName;

      await channel.assertExchange(exchange, 'topic', { durable: true });
      channel.publish(
        exchange,
        routingKey,
        Buffer.from(
          JSON.stringify({
            entityName,
            entityId,
            eventName: event.eventName,
            body: event.body,
            timestamp: event.eventCreatedAt
          })
        ),
        { persistent: true }
      );
    }

    await channel.close();
    await connection.close();
  }
};
```

### AWS SNS Integration

```typescript
import { SNSClient, PublishCommand } from '@aws-sdk/client-sns';

const snsEventPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events }) {
    const client = new SNSClient({ region: process.env.AWS_REGION });

    for (const event of events) {
      const topicArn = `arn:aws:sns:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:${entityName}-events`;

      await client.send(
        new PublishCommand({
          TopicArn: topicArn,
          Subject: event.eventName,
          Message: JSON.stringify({
            entityName,
            entityId,
            eventName: event.eventName,
            body: event.body,
            timestamp: event.eventCreatedAt
          })
        })
      );
    }
  }
};
```

### Google Pub/Sub Integration

```typescript
import { PubSub } from '@google-cloud/pubsub';

const pubsubEventPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events }) {
    const pubsub = new PubSub({
      projectId: process.env.GCP_PROJECT_ID
    });

    for (const event of events) {
      const topicName = `${entityName}-events`;
      const topic = pubsub.topic(topicName);

      const message = {
        entityName,
        entityId,
        eventName: event.eventName,
        body: event.body,
        timestamp: event.eventCreatedAt
      };

      await topic.publish(Buffer.from(JSON.stringify(message)));
    }
  }
};
```

## Best Practices

### Do's

```typescript
// Do: Include event metadata for tracing
const tracedPlugin: Plugin = {
  async onCommitted({ entityName, entityId, events }) {
    for (const event of events) {
      const message = {
        eventId: event.eventId, // For idempotency
        eventName: event.eventName,
        entityName,
        entityId,
        body: event.body,
        timestamp: event.eventCreatedAt,
        publishedAt: new Date().toISOString()
      };
      await eventBus.publish(message);
    }
  }
};

// Do: Handle failures gracefully
const resilientPlugin: Plugin = {
  async onCommitted({ events }) {
    for (const event of events) {
      try {
        await eventBus.publish(event);
      } catch (error) {
        // Queue for retry
        await retryQueue.enqueue({ event, error });
        logger.warn('Event broadcast failed, queued for retry', { error });
      }
    }
  }
};

// Do: Filter sensitive events
const securePlugin: Plugin = {
  async onCommitted({ events }) {
    const publicEvents = events.filter(e =>
      !e.eventName.includes('internal')
    );

    for (const event of publicEvents) {
      await eventBus.publish(event);
    }
  }
};
```

### Don'ts

```typescript
// Don't: Broadcast sensitive information
// BAD
const badPlugin: Plugin = {
  async onCommitted({ events }) {
    // Broadcasting passwords, tokens, etc.!
    for (const event of events) {
      await eventBus.publish(event);
    }
  }
};

// GOOD: Redact sensitive data
const goodPlugin: Plugin = {
  async onCommitted({ events }) {
    for (const event of events) {
      const sanitized = {
        ...event,
        body: redactSensitiveFields(event.body)
      };
      await eventBus.publish(sanitized);
    }
  }
};

// Don't: Block commit on broadcast failures
// BAD: Throwing errors blocks commit
const blockingPlugin: Plugin = {
  async onCommitted({ events }) {
    for (const event of events) {
      // This can throw and block the commit!
      await eventBus.publish(event);
    }
  }
};

// GOOD: Handle failures gracefully
const nonBlockingPlugin: Plugin = {
  async onCommitted({ events }) {
    for (const event of events) {
      try {
        await eventBus.publish(event);
      } catch (error) {
        // Queue for retry, don't throw
        await retryQueue.enqueue({ event, error });
      }
    }
  }
};

// Don't: Broadcast at high frequency without batching
// BAD: One HTTP request per event
const slowPlugin: Plugin = {
  async onCommitted({ events }) {
    for (const event of events) {
      await fetch('...', { body: event }); // Slow!
    }
  }
};

// GOOD: Batch events
const fastPlugin: Plugin = {
  async onCommitted({ events }) {
    // One request for all events
    await fetch('...', { body: events });
  }
};
```

## Idempotency Handling

Ensure exactly-once delivery semantics:

```typescript
const idempotentBroadcastPlugin: Plugin = {
  async onCommitted({ events }) {
    for (const event of events) {
      await eventBus.publish(
        event.eventName,
        {
          entityName,
          entityId,
          body: event.body,
          timestamp: event.eventCreatedAt
        },
        {
          // Use event ID for idempotency
          idempotencyKey: event.eventId
        }
      );
    }
  }
};
```

## Testing

Test event broadcasting with mocks:

```typescript
import { describe, it, expect, vi } from 'vitest';

describe('Event Broadcasting Plugin', () => {
  it('publishes all committed events', async () => {
    const publishMock = vi.fn();
    const mockEventBus = { publish: publishMock };

    const events = [
      {
        eventName: 'user:created',
        eventId: '1',
        body: { email: 'test@example.com' },
        eventCreatedAt: '2024-01-01T00:00:00Z'
      }
    ];

    await eventBroadcastPlugin.onCommitted({
      entityName: 'user',
      entityId: 'user-123',
      events,
      state: { email: 'test@example.com' }
    });

    expect(publishMock).toHaveBeenCalled();
    const call = publishMock.mock.calls[0];
    expect(call[0]).toBe('user:created');
  });
});
```

## Related Documentation

- [Plugins Overview](/docs/plugins)
- [Analytics Plugin](/docs/plugins/analytics)
- [Creating Custom Plugins](/docs/plugins/creating-plugins)
