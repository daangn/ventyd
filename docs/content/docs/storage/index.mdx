---
title: Storage Adapters Overview
description: Storage adapters connect Ventyd to your database. Learn about the adapter interface, implementation guidelines, and how to choose the right storage solution.
---

# Storage Adapters Overview

Storage adapters are the bridge between Ventyd's event sourcing system and your database. They handle all persistence operations, allowing you to use any database that fits your needs.

## What is a Storage Adapter?

A storage adapter implements two core operations:

1. **Retrieve Events**: Load all events for a specific entity from your database
2. **Persist Events**: Save new events atomically to ensure consistency

This simple interface gives you the flexibility to integrate with any database technology.

## Adapter Interface

Every adapter must implement the `Adapter` interface:

```typescript
interface Adapter {
  /**
   * Retrieve all events for a specific entity
   * Events must be returned in chronological order
   */
  getEventsByEntityId(params: {
    entityName: string;
    entityId: string;
  }): Promise<Event[]>;

  /**
   * Persist events to storage
   * All events must be saved atomically
   */
  commitEvents(params: {
    events: Event[];
  }): Promise<void>;
}
```

### Method Details

#### getEventsByEntityId()

Retrieves all events for a specific entity in chronological order.

- **Parameters**:
  - `entityName`: The type of entity (e.g., "user", "order")
  - `entityId`: The unique identifier of the entity instance
- **Returns**: Array of `Event` objects sorted by creation time (ascending)
- **Must guarantee**: Events are returned in the order they occurred

```typescript
async getEventsByEntityId({ entityName, entityId }) {
  // Query database for all events matching the entity
  const events = await database.query(
    'SELECT * FROM events WHERE entity_name = ? AND entity_id = ? ORDER BY created_at ASC',
    [entityName, entityId]
  );
  return events;
}
```

#### commitEvents()

Persists events to storage with atomic guarantees.

- **Parameters**:
  - `events`: Array of event objects to persist
- **Returns**: Promise that resolves when all events are safely stored
- **Must guarantee**: Either all events are saved or none are (atomicity)

```typescript
async commitEvents({ events }) {
  // Save all events atomically
  const transaction = await database.beginTransaction();
  try {
    for (const event of events) {
      await transaction.insert('events', event);
    }
    await transaction.commit();
  } catch (error) {
    await transaction.rollback();
    throw error;
  }
}
```

## Choosing a Storage Adapter

Consider these factors when selecting or implementing an adapter:

### Development & Testing
**Use In-Memory Adapter** when:
- Developing new features
- Running unit tests
- Prototyping
- State doesn't need to persist between sessions

Benefits:
- No external dependencies
- Fast in-memory operations
- Easy to debug

Limitations:
- Data lost on restart
- Single-process only
- Not suitable for production

### Small to Medium Production
**Use MongoDB Adapter** when:
- You need document-based storage
- Schema flexibility is important
- Horizontal scaling is a priority
- You want good ecosystem support

Benefits:
- Flexible schema
- Horizontal scalability
- Rich query language
- Strong ecosystem

Limitations:
- Slightly higher overhead than SQL
- Less suited for complex transactions

### Enterprise Production
**Use PostgreSQL Adapter** when:
- You need strong ACID guarantees
- Complex relationships matter
- Data consistency is critical
- You're already using PostgreSQL

Benefits:
- ACID compliance
- Powerful transactions
- Mature ecosystem
- Excellent performance

Limitations:
- Requires schema management
- Vertical scaling focus
- More operational overhead

## Adapter Implementation Checklist

When implementing a custom adapter, ensure:

- [ ] `getEventsByEntityId()` returns events in **strict chronological order**
- [ ] `commitEvents()` is **atomic** - all events saved or none
- [ ] Both methods handle **errors gracefully**
- [ ] Appropriate **indexes** are created for performance
- [ ] **Connection pooling** is configured (for SQL databases)
- [ ] Queries handle **large result sets** efficiently
- [ ] **Transaction support** is properly implemented

## Common Adapter Patterns

### Connection Management

Most database adapters follow a similar pattern:

```typescript
import type { Adapter } from 'ventyd';

const createDatabaseAdapter = (config: DatabaseConfig): Adapter => {
  // Initialize connection pool
  const pool = createConnectionPool(config);

  return {
    async getEventsByEntityId({ entityName, entityId }) {
      const conn = await pool.acquire();
      try {
        return await conn.query(
          'SELECT * FROM events WHERE entity_name = ? AND entity_id = ? ORDER BY created_at',
          [entityName, entityId]
        );
      } finally {
        pool.release(conn);
      }
    },
    async commitEvents({ events }) {
      const conn = await pool.acquire();
      try {
        await conn.transaction(async () => {
          for (const event of events) {
            await conn.insert('events', event);
          }
        });
      } finally {
        pool.release(conn);
      }
    }
  };
};
```

### Error Handling

Implement consistent error handling:

```typescript
async commitEvents({ events }) {
  try {
    await db.insertMany(events);
  } catch (error) {
    if (isDuplicateKeyError(error)) {
      // Event already exists - likely a retry
      console.warn('Duplicate event', error);
      return;
    }

    if (isConnectionError(error)) {
      // Retry connection
      throw new Error('Database connection failed', { cause: error });
    }

    throw error;
  }
}
```

### Event Ordering Verification

Always verify event ordering:

```typescript
async getEventsByEntityId({ entityName, entityId }) {
  const events = await db.find({
    entityName,
    entityId
  }).sort({ eventCreatedAt: 1 }).toArray();

  // Verify ordering
  for (let i = 1; i < events.length; i++) {
    const prev = new Date(events[i - 1].eventCreatedAt).getTime();
    const curr = new Date(events[i].eventCreatedAt).getTime();

    if (prev > curr) {
      throw new Error('Events not in chronological order');
    }
  }

  return events;
}
```

## Performance Considerations

### Indexing Strategy

Every adapter should have indexes for:

```typescript
// Primary lookup index
db.createIndex({ entityName: 1, entityId: 1 });

// For range queries and sorting
db.createIndex({ eventCreatedAt: 1 });

// Optional: For event filtering
db.createIndex({ eventName: 1 });

// Optional: For range queries on creation time
db.createIndex({ entityName: 1, eventCreatedAt: 1 });
```

### Batch Operations

Use batch operations instead of loops:

```typescript
// ✅ Good - Batch insert
async commitEvents({ events }) {
  await db.insertMany(events); // Single operation
}

// ❌ Avoid - Individual inserts
async commitEvents({ events }) {
  for (const event of events) {
    await db.insert(event); // Multiple operations
  }
}
```

### Connection Pooling

Always use connection pooling:

```typescript
// ✅ Good
const pool = new Pool({
  max: 20,
  min: 5,
  idleTimeoutMillis: 30000
});

// ❌ Avoid
const connection = await createNewConnection(); // Every time
```

## Best Practices

### 1. Maintain Event Order

Events must always be retrieved in the exact order they were created:

```typescript
async getEventsByEntityId({ entityName, entityId }) {
  return await db.query(
    `SELECT * FROM events
     WHERE entity_name = ? AND entity_id = ?
     ORDER BY event_created_at ASC`,
    [entityName, entityId]
  );
}
```

### 2. Atomic Commits

All events in a single commit must be persisted atomically:

```typescript
async commitEvents({ events }) {
  const transaction = await db.startTransaction();
  try {
    for (const event of events) {
      await transaction.insert(event);
    }
    await transaction.commit();
  } catch (error) {
    await transaction.rollback();
    throw error;
  }
}
```

### 3. Handle Empty Commits

Always handle the case where no events need to be persisted:

```typescript
async commitEvents({ events }) {
  if (events.length === 0) {
    return; // Nothing to save
  }

  await db.insertMany(events);
}
```

### 4. Graceful Error Handling

Provide clear error messages:

```typescript
async getEventsByEntityId({ entityName, entityId }) {
  try {
    return await db.query(...);
  } catch (error) {
    throw new Error(
      `Failed to retrieve events for ${entityName}:${entityId}`,
      { cause: error }
    );
  }
}
```

> **Note:** We recommend implementing adapters that support idempotent operations. If a commit fails and is retried, the adapter should gracefully handle duplicate events (e.g., by using unique constraints on `eventId`).

## Next Steps

- **[In-Memory Adapter](/docs/storage/in-memory)** - For development and testing
- **[MongoDB Adapter](/docs/storage/mongodb)** - For production with MongoDB
- **[PostgreSQL Adapter](/docs/storage/postgresql)** - For production with PostgreSQL
- **[Custom Adapters](/docs/storage/custom-adapters)** - Creating adapters for other databases
