---
title: Introduction
description: A TypeScript-first event sourcing library built for modern web applications
---

# Welcome to Ventyd

**Ventyd** is a TypeScript-first event sourcing library that makes it easy to build applications where every state change is captured as an immutable event.

## Why Ventyd?

Traditional applications only store the current state of your data. Ventyd takes a different approach - it stores **all the events** that led to the current state, giving you superpowers like complete audit trails, time travel debugging, and event replay.

<Cards>
  <Card
    title="Type-Safe"
    description="Full TypeScript support with comprehensive type inference. Catch errors at compile time."
    href="/docs/getting-started"
  />
  <Card
    title="Flexible Validation"
    description="Use Valibot, Zod, ArkType, TypeBox, or any Standard Schema library."
    href="/docs/validation"
  />
  <Card
    title="Database Agnostic"
    description="Simple adapter interface works with MongoDB, PostgreSQL, Redis, or custom solutions."
    href="/docs/storage"
  />
  <Card
    title="Extensible"
    description="Plugin system for analytics, logging, notifications, and custom side effects."
    href="/docs/plugins"
  />
</Cards>

## Quick Example

Here's a complete example of an event-sourced User entity:

```typescript
import { defineSchema, defineReducer, Entity, mutation, createRepository } from 'ventyd';
import { valibot, v } from 'ventyd/valibot';

// 1. Define your schema
const userSchema = defineSchema("user", {
  schema: valibot({
    event: {
      created: v.object({
        email: v.pipe(v.string(), v.email()),
        name: v.string(),
      }),
      name_updated: v.object({
        name: v.string(),
      }),
    },
    state: v.object({
      email: v.string(),
      name: v.string(),
    }),
  }),
  initialEventName: "user:created",
});

// 2. Create a reducer
const userReducer = defineReducer(userSchema, (prevState, event) => {
  switch (event.eventName) {
    case "user:created":
      return {
        email: event.body.email,
        name: event.body.name,
      };
    case "user:name_updated":
      return {
        ...prevState,
        name: event.body.name,
      };
    default:
      return prevState;
  }
});

// 3. Build your entity
class User extends Entity(userSchema, userReducer) {
  get email() {
    return this.state.email;
  }

  get name() {
    return this.state.name;
  }

  updateName = mutation(this, (dispatch, name: string) => {
    if (name.length === 0) {
      throw new Error("Name cannot be empty");
    }
    dispatch("user:name_updated", { name });
  });
}

// 4. Create a repository
const userRepository = createRepository(User, {
  adapter: createInMemoryAdapter()
});

// 5. Use it!
const user = User.create({
  body: { email: "alice@example.com", name: "Alice" }
});

user.updateName("Alice Smith");

await userRepository.commit(user);
```

## Key Features

### Complete Audit Trail

Every change is recorded as an immutable event:

```typescript
console.log(user.events);
// [
//   { eventName: 'user:created', body: { email: '...', name: 'Alice' } },
//   { eventName: 'user:name_updated', body: { name: 'Alice Smith' } }
// ]
```

### Time Travel

Reconstruct state at any point in history:

```typescript
// Replay only the first event
const pastState = events.slice(0, 1).reduce(reducer, undefined);
console.log(pastState.name); // "Alice" (before the update)
```

### Event Replay

Rebuild your entire database from events:

```typescript
// Migrate to a new schema by replaying all events
const events = await getAllEvents();
const newState = events.reduce(newReducer, undefined);
```

### Flexible Validation

Choose your favorite validation library:


  
    ```typescript
    import { valibot, v } from 'ventyd/valibot';

    const schema = valibot({
      event: {
        created: v.object({
          email: v.pipe(v.string(), v.email())
        })
      },
      state: v.object({
        email: v.string()
      })
    });
    ```
  
  
    ```typescript
    import { zod, z } from 'ventyd/zod';

    const schema = zod({
      event: {
        created: z.object({
          email: z.string().email()
        })
      },
      state: z.object({
        email: z.string()
      })
    });
    ```
  
  
    ```typescript
    import { typebox, Type } from 'ventyd/typebox';

    const schema = typebox({
      event: {
        created: Type.Object({
          email: Type.String({ format: 'email' })
        })
      },
      state: Type.Object({
        email: Type.String()
      })
    });
    ```
  
  
    ```typescript
    import { arktype, type } from 'ventyd/arktype';

    const schema = arktype({
      event: {
        created: type({
          email: "string.email"
        })
      },
      state: type({
        email: "string.email"
      })
    });
    ```
  


## Get Started


  
    ### Install Ventyd

    ```bash
    npm install ventyd valibot
    ```

    Choose your preferred validation library (Valibot, Zod, ArkType, or TypeBox).
  

  
    ### Follow the Quick Start

    Build your first event-sourced entity in 5 minutes.

    [Quick Start Guide →](/docs/getting-started/quick-start)
  

  
    ### Learn Core Concepts

    Understand event sourcing, entities, reducers, and mutations.

    [Core Concepts →](/docs/core-concepts)
  


## Documentation Sections

<Cards>
  <Card
    title="Getting Started"
    description="Installation, quick start, and your first entity"
    href="/docs/getting-started"
  />
  <Card
    title="Core Concepts"
    description="Event sourcing, entities, events, reducers, mutations, and CQRS"
    href="/docs/core-concepts"
  />
  <Card
    title="Validation"
    description="Complete guides for Valibot, Zod, TypeBox, ArkType, and Standard Schema"
    href="/docs/validation"
  />
  <Card
    title="Storage"
    description="In-memory, MongoDB, PostgreSQL adapters and custom implementations"
    href="/docs/storage"
  />
  <Card
    title="Plugins"
    description="Analytics, audit logging, event broadcasting, search indexing, and more"
    href="/docs/plugins"
  />
  <Card
    title="Guides"
    description="Event naming, testing, performance, error handling, and best practices"
    href="/docs/guides"
  />
</Cards>

## Community & Support

<Cards>
  <Card
    title="GitHub"
    description="Source code, issues, and contributions"
    href="https://github.com/daangn/ventyd"
  />
  <Card
    title="Issues"
    description="Report bugs or request features"
    href="https://github.com/daangn/ventyd/issues"
  />
  <Card
    title="License"
    description="MIT - Free for commercial and personal use"
  />
</Cards>

## What's Different About Ventyd?

### Standard Schema First

Ventyd is built on the [Standard Schema](https://standardschema.dev) specification, which means you're not locked into any single validation library. Switch between Valibot, Zod, ArkType, or TypeBox without changing your code structure.

### Type Safety Everywhere

Full TypeScript support with comprehensive type inference means you catch errors at compile time, not runtime.

```typescript
// ✅ TypeScript knows exactly what events are valid
user.updateName("Alice"); // Works!

// ❌ TypeScript catches invalid events at compile time
user.dispatch("user:invalid_event", {}); // Type error!
```

### CQRS by Default

Ventyd separates read and write models automatically. Entities loaded from state snapshots are read-only, preventing accidental mutations without event history.

```typescript
// Write model - can mutate
const user = User.create({ body: { email: "..." } });
user.updateName("Alice"); // ✅ Works

// Read model - read-only
const loaded = User.load({ entityId: "123", state: { email: "..." } });
loaded.updateName("Bob"); // ❌ Type error & runtime error
```

### Lightweight & Focused

Ventyd has minimal dependencies and focuses on core event sourcing functionality. Extend it with plugins for side effects like analytics, logging, and notifications.

<Callout type="info">
**Ready to Get Started?**

Jump into the [Quick Start guide](/docs/getting-started/quick-start) and build your first event-sourced entity in 5 minutes!
</Callout>
